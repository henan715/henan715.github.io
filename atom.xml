<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FlyingFire</title>
  
  <subtitle>数据挖掘、数据分析、数据运营混合体，魔都Fintech行业搬砖工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-02T04:26:09.169Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FlyingFire</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新一代Python虚拟环境库Pipenv学习笔记</title>
    <link href="http://yoursite.com/2018/06/02/%E6%96%B0%E4%B8%80%E4%BB%A3Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%BA%93Pipenv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/02/新一代Python虚拟环境库Pipenv学习笔记/</id>
    <published>2018-06-02T03:47:29.000Z</published>
    <updated>2018-06-02T04:26:09.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>pipenv</code>是<code>requests</code>作者的一个项目, 整合了<code>virtualenv</code>, <code>pip</code>, <code>pipfile</code>, 用于更方便地为项目建立虚拟环境并管理虚拟环境中的第三方模块。</p><p>为什么用<code>pipenv</code>取代<code>virtualenv</code>呢，参照<a href="https://zhuanlan.zhihu.com/p/32913361" target="_blank" rel="external">这篇文章</a>提出了<code>virtualenv</code>的几个缺点：</p><ol><li>必须手动安装或删除某些特定版本的包，并记得定期更新requirements.txt文件，以保持项目环境的一致</li><li>有时项目中需要有多个requirements.txt文件，比如开发时应该用dev-requirements.txt，现有的模式不能满足这些复杂的需要</li><li>卸载包的时候只是卸载包自己，不能处理相关依赖，时间久了项目环境就混乱了</li></ol><p>而<code>pipenv</code>在前辈的基础上进行了优化，参照<a href="https://docs.pipenv.org/" target="_blank" rel="external">官网</a>，更新了如下特性：</p><ol><li>根据 Pipfile 自动寻找项目根目录。</li><li>如果不存在，可以自动生成 Pipfile 和 Pipfile.lock。</li><li>自动在项目目录的 .venv 目录创建虚拟环境。（当然这个目录地址通过设置WORKON_HOME改变）</li><li>自动管理 Pipfile 新安装和删除的包。</li><li>自动更新 pip。</li></ol><p>最大的区别在于：</p><ul><li><code>virtualenv</code>使用requirements.txt这种纯文本管理库，而<code>pipenv</code>使用<code>TOML</code>格式的pipfile文件进行管理，你可以根据实际需要建立开发环境和正式环境的pipfile，并且支持版本锁定，更智能、更自动、更高效；</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>linux下使用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pipenv</div></pre></td></tr></table></figure><p>MAC下使用brew安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install pipenv</div></pre></td></tr></table></figure><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="3-1、创建并打开虚拟环境"><a href="#3-1、创建并打开虚拟环境" class="headerlink" title="3.1、创建并打开虚拟环境"></a>3.1、创建并打开虚拟环境</h3><p>最基础的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># step1、创建目录，并进入目录</span></div><div class="line">mkdir test_env</div><div class="line"><span class="built_in">cd</span> test_env</div><div class="line"></div><div class="line"><span class="comment"># step2、建立虚拟环境</span></div><div class="line">pipenv --two  <span class="comment"># 默认使用python2建立虚拟环境，使用--three则使用python3</span></div><div class="line"></div><div class="line"><span class="comment"># step3、激活虚拟环境</span></div><div class="line">pipenv shell</div><div class="line"></div><div class="line"><span class="comment"># step4、安装其他库</span></div><div class="line">pip install numpy pandas</div><div class="line"></div><div class="line"><span class="comment"># step5、退出虚拟环境</span></div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure><p><img src="/home/henan/hexoMy/henan715.github.io/source/_posts/新一代Python虚拟环境库Pipenv学习笔记/01.gif" alt="01"></p><h3 id="3-2、进阶命令"><a href="#3-2、进阶命令" class="headerlink" title="3.2、进阶命令"></a>3.2、进阶命令</h3><p>创建指定版本的python虚拟环境(pipenv会自动扫描系统中是否有符合的版本)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pipenv --python 3</div><div class="line">pipenv --python 3.6</div><div class="line">pipenv --python 2.7.14</div></pre></td></tr></table></figure><p>从旧的<code>requirements.txt</code>安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv install -r path/to/requirements.txt</div></pre></td></tr></table></figure><p>安装指定版本的库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv install requests==2.13.0</div></pre></td></tr></table></figure></p><p>卸载指定的库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pipenv uninstall package_name</div><div class="line">pipenv uninstall --all <span class="comment"># 移除所有库</span></div><div class="line">pipenv uninstall --all-dev <span class="comment"># 移除测试环境所有的库</span></div></pre></td></tr></table></figure></p><p>创建lock文件，lock文件声明了所有的依赖以及子依赖信息，通常随着发布包一起发布：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv lock</div></pre></td></tr></table></figure></p><p>查看库依赖关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv graph</div></pre></td></tr></table></figure><h3 id="3-3、高级用法"><a href="#3-3、高级用法" class="headerlink" title="3.3、高级用法"></a>3.3、高级用法</h3><p>pipfile是pipenv自动生成的关于环境、库依赖等信息的文件，大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">source</span>]]</div><div class="line">url = <span class="string">"https://pypi.python.org/simple"</span></div><div class="line">verify_ssl = <span class="literal">true</span></div><div class="line">name = <span class="string">"pypi"</span></div><div class="line"></div><div class="line">[packages]</div><div class="line">numpy = <span class="string">"*"</span></div><div class="line">pandas = <span class="string">"*"</span></div><div class="line"></div><div class="line">[dev-packages]</div></pre></td></tr></table></figure><p>将pipfile转化为requirements.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pipenv lock -r</div><div class="line">pipenv locl -r --dev <span class="comment"># 输出测试环境的pipfile依赖</span></div></pre></td></tr></table></figure><p><a href="https://docs.pipenv.org/advanced/#caveats" target="_blank" rel="external">官方文档</a>还介绍了一些其他的命令，感兴趣的可以翻阅一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pipenv&lt;/code&gt;是&lt;code&gt;requests&lt;/code&gt;作者的一个项目, 整合了&lt;code&gt;vir
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>电信思考</title>
    <link href="http://yoursite.com/2018/05/26/%E7%94%B5%E4%BF%A1%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/05/26/电信思考/</id>
    <published>2018-05-26T13:38:46.000Z</published>
    <updated>2018-06-02T03:46:19.057Z</updated>
    
    <content type="html"><![CDATA[<p>今天前往电信营业厅办理宽带业务，排队排了一个小时，业务办理10分钟，在排队之余，观察起营业厅的状况，今天是周六，营业厅10个坐席有5位值班人员，在我观察的1个小时中，他们的业务状态如下：</p><ul><li>1号：接待4位客户A1-A4，办理时间分别是16、23、7、15，总计61；</li><li>2号：接待3位客户B1-B3，办理时间分别是12、25、 11，总计48；</li><li>3号：接待2位客户C1-C2，办理时间分别是20、13，总计33；</li><li>4号：接待3位客户D1-D3，办理时间分别是18、24、13，总计55；</li><li>5号：接待1位客户E1，办理时间是45，总计45；</li></ul><p>感觉营业厅就像是CPU，每一位办理业务的客户就是CPU中的一个作业，营业厅选择的作业调度模式是先来先服务(FCFS)模式，保证先来的客户先收到服务，我们知道CPU作业调度中还有一种短作业优先(SJF)模式，那么我们能否根据这两种调度模式尝试优化营业厅坐席业务流程呢？</p><p>我们将5位坐席人员调整如下：</p><ul><li>1号：处理小于15分钟内的业务；</li><li>2号：处理15-20分钟内的业务；</li><li>3号：处理大于20分钟的业务，每任务限时30分钟；</li><li>4号：处理大于20分钟的业务，每任务限时40分钟；</li><li>5号：浮动，1-4号办理业务超时时立即接手后续的客户</li></ul><p>那么客户的分配如下：</p><ul><li>1号：A3、A4、B1、B3、C2，总计耗时7+15+12+13=47，比原始模式节省了14分钟</li><li>2号：A1、D1，总计耗时16+18=34，比原始模式节省了14分钟</li><li>3号：A2、B2，总计耗时23+25=48，比原始模式增加了15分钟</li><li>4号：C1、D2、E1，总计耗时20+24+45=85，比原始模式增加了30分钟</li><li>5号：浮动，总耗时0</li></ul><p>这种情况下虽然有提升的情况(1号，用更少的时间接待了更多的人)，但也有劣化的情况(4号，同样的人数用了更多的时间)，那么有没有更好的方法呢？</p><p><a href="http://www.docin.com/p-1373624360.html" target="_blank" rel="external">营业厅排队等待问题分析与解决办法</a>这篇文章介绍了排队等待的造成因素有哪些，提出了提高效率、优化管理等方式，个人感觉治标不治本，如何提升效率？如何优化管理？业务员已经满负载运行的情况下再如何提升？大堂经理走动巡堂只能满足小部分需求，无法真正优化管理流程；<a href="https://wenku.baidu.com/view/07e866991a37f111f1855ba1.html" target="_blank" rel="external">中国移动营业厅排队服务流程分析</a>这篇文章介绍了一种大厅经理导流的方法，缺陷依然如上；<a href="http://www.doc88.com/p-9965172746565.html" target="_blank" rel="external">基于需求管理的电信营业厅排队优化措施</a>这篇文章介绍了一种基于业务时间的优化方法，并用具体的例子进行了论证，但文章缺失较多，参考价值不大，写到这里，我自己也似乎有点泄气，专家都解决不了的办法难道凭你坐在沙发上脑子转转就能解决吗？</p><p>如果我不能完全解决这个问题，那么至少我可以提出我的一些想法吧，我觉得用有一个最关键的前提，是需要提前知道客户办理的业务需要多少时间，这里我想出的方案有两个方向：</p><ul><li><p>优化取号机器</p><p>当前的取号机可以说非常原始，往往只分了几个简单的类别，是不是可以在深深度挖掘一下历史客户的业务行为，客户办理什么业务，他的诉求是什么，过程中衍生着办理了什么需求，根据这个优化取号机的交互界面，比如我就是单纯的要退订一个宽带，那么交互的逻辑就应该是“业务办理与退订–宽带业务–退订–是否还需办理其他业务–无–确认”，出来的号单应该提示我需要准备哪些材料，不清楚的可以和大堂经理咨询，从源头上先预判客户业务办理的时间。</p></li><li><p>将数据统计思维融入业务办理过程</p><p>每个业务员办理不同业务的时间的分布是怎样的？每个业务员擅长的业务是什么样的？不同年龄客户办理同一个业务所需要的时间是怎样的？简单的数据统计就可以回答上述问题，根据不同业务的类型、时间、频次分布合理的安排值班人员，根据不同业务人员的特长、熟练度、层次优化业务接待流程，根据不同的客户诉求合理的安排业务员，终极的目标是业务量上去了、业务员工作量下来了、客户满意度高了。</p></li></ul><p>都说利用大数据提升服务质量，但总感觉喊口号的多，干实事的少，统计上述数据难么？不难，只是提升服务质量当前还是一种锦上添花，远不如拉取新客提升业务量这种雪中送炭来的重要。</p><p>我想每位技术人员都应该持续思考，如何用技术更好的服务客户，技术不应该浮在天上缥缈无痕，技术应该是接地气甚至应该是土气的，好的技术应该让人感到幸福，让客户收到更优质的服务，让业务人员更轻松，最后送上前段时间的一个段子，搞笑却说出了道理：</p><blockquote><p>记者：马云推出无人超市了，您怎么看？<br>记者：大妈，无人超市不是没有人这个意思，而是说，超市里没有售货员收银员等等员工了。<br>大妈：那应该叫无员工超市啊！哎，就你们这语文水平，还当记者呢？<br>记者：是是，大妈说得对，应该叫无员工超市。大妈，那您对这种新型的超市有什么看法呢？<br>大妈：超市不需要养员工了，那东西是不是更便宜啦？<br>记者：这个？我们暂时还没了解到。<br>大妈：瞧瞧你们这些记者怎么当的？老百姓最关心的问题，你们不去了解，整天只会关心马云又弄啥玩意了。我们老百姓最关心的是什么？有没有假货，是不是更便宜啦！超市里有没有员工，关我啥事？<br>记者：您不觉得无人超市的推出将会改变我们传统的购物方式吗？<br>大妈：改变啥哟？买东西不花钱啦？刷刷支付宝那也是花钱呐！<br>记者：大妈，看来您还是不能理解时代的发展潮流。<br>大妈：哟，弄个没有员工的超市就是时代潮流啦？每天都弄些专门裁剪底层员工的玩意算啥本事？有本事弄个没有老板的超市啊？<br>记者：大妈，您对马云是不是有意见啊？<br>大妈：我不是对马云有意见，是对你这种无聊的记者有意见，问问题从来都问不到点。马云改变了我们的生活，但我们要的不仅仅是改变，而是带来幸福的改变。现在很多改变不仅没有增添我们的幸福，还增添了许多烦恼！这才是你们记者应该关注的问题。</p></blockquote><p>愿科技改变生活，科技让人幸福。</p><p>(ps.文章逻辑略乱，见谅)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天前往电信营业厅办理宽带业务，排队排了一个小时，业务办理10分钟，在排队之余，观察起营业厅的状况，今天是周六，营业厅10个坐席有5位值班人员，在我观察的1个小时中，他们的业务状态如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1号：接待4位客户A1-A4，办理时间分别是16、23、7、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XGBoost安装手册</title>
    <link href="http://yoursite.com/2017/11/13/Anaconda%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/11/13/Anaconda安装、配置/</id>
    <published>2017-11-13T12:48:40.437Z</published>
    <updated>2017-11-13T12:48:40.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p>在<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">这里</a>下载最新版本Anaconda，下载完成后，用<code>root</code>用户在控制台执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh Anaconda3-5.0.1-Linux-x86_64.sh</div></pre></td></tr></table></figure><p>添加清华源，加快插件下载速度，详情参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="external">这里</a>。</p><p>添加<code>XGBoost</code>，添加方法参考<a href="https://anaconda.org/akode/xgboost" target="_blank" rel="external">这里</a>或者如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># step1、(如果安装过程出错提示“无法找到g++”时)安装g++</span></div><div class="line">sudo apt-get install g++</div><div class="line"></div><div class="line"><span class="comment"># step2、pip安装</span></div><div class="line">pip install -y xgboost</div></pre></td></tr></table></figure><p><code>Anaconda</code>自带的<code>Jupyter Notebook</code>可以安装插件使之更好用，如代码折叠、黑色主题等，安装及配置方法可以参考<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="external">这里</a>，ps.这个库如果安装过程中出现和http异常的情况时，多试几次就可以。</p><p>参考<a href="http://www.itwendao.com/article/detail/460543.html" target="_blank" rel="external">这里</a>使用<code>MNIST</code>搭建demo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XGBoost&quot;&gt;&lt;a href=&quot;#XGBoost&quot; class=&quot;headerlink&quot; title=&quot;XGBoost&quot;&gt;&lt;/a&gt;XGBoost&lt;/h1&gt;&lt;h2 id=&quot;一、下载&quot;&gt;&lt;a href=&quot;#一、下载&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="XGBoost" scheme="http://yoursite.com/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>Keras入门学习</title>
    <link href="http://yoursite.com/2017/11/13/Keras%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/11/13/Keras入门学习/</id>
    <published>2017-11-13T12:47:30.000Z</published>
    <updated>2017-11-13T13:01:11.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Keras是一个用Python编写的、高度封装的、支持Tensorflow、CNTK、Theano的神经网络库。</p><h1 id="一、Keras模型"><a href="#一、Keras模型" class="headerlink" title="一、Keras模型"></a>一、Keras模型</h1><p>“模型”是Keras的核心数据结构，有两种模型：最基础的是Sequential模型，他是网络顺序叠加形成的栈，另一种是使用函数式接口创建的更加复杂的模型。</p><h2 id="Sequential模型"><a href="#Sequential模型" class="headerlink" title="Sequential模型"></a>Sequential模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sequential模型</span></div><div class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</div><div class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Activation</div><div class="line"></div><div class="line"><span class="comment"># 创建模型</span></div><div class="line">model = Sequential()</div><div class="line"></div><div class="line"><span class="comment"># 添加网络层</span></div><div class="line">model.add(Dense(units=<span class="number">64</span>, input_dim=<span class="number">100</span>))</div><div class="line">model.add(Activation(<span class="string">'relu'</span>))</div><div class="line">model.add(Dense(units=<span class="number">10</span>))</div><div class="line">model.add(Activation(<span class="string">'softmax'</span>))</div><div class="line"></div><div class="line"><span class="comment"># 编译模型，编译模型时必须制定损失函数和优化函数</span></div><div class="line">model.compile(loss=<span class="string">'categorial_crossentropy'</span>, optimizer=<span class="string">'sgd'</span>, metrics=[<span class="string">'accuracy'</span>])</div><div class="line"><span class="comment"># keras模块化的设计原则可以灵活的设计网络结构，如：</span></div><div class="line"><span class="comment"># from keras.optimizers import SGD</span></div><div class="line"><span class="comment"># model.compile(loss='categorical_crossentropy', optimizer=SGD(lr=0.01, momentum=0.9, nesterov=True))</span></div><div class="line"></div><div class="line"><span class="comment"># 按批次训练网络</span></div><div class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>, batch_size=<span class="number">32</span>)</div><div class="line"><span class="comment"># 或者手动逐个批次的训练</span></div><div class="line"><span class="comment"># model.train_on_batch(x_batch, y_batch)</span></div><div class="line"></div><div class="line"><span class="comment"># 评估模型</span></div><div class="line">loss_and_metrics = model.evaluate(x_test, y_test, batch_size=<span class="number">128</span>)</div><div class="line"><span class="comment"># 或者预测新数据</span></div><div class="line">classes = model.predict(x_test, batch_size=<span class="number">128</span>)</div></pre></td></tr></table></figure><h2 id="Functional模型"><a href="#Functional模型" class="headerlink" title="Functional模型"></a>Functional模型</h2><p>Keras函数式模型接口是用户定义多输出模型、非循环有向模型或具有共享层的模型等复杂模型的途径。函数式模型是最广泛的一类模型，序贯模型（Sequential）只是它的一种特殊情况。</p><p><strong>全连接层模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</div><div class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</div><div class="line"></div><div class="line">inputs = Input(shape=(<span class="number">784</span>,))</div><div class="line">x = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(inputs) <span class="comment"># 第一层relu</span></div><div class="line">x = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(x) <span class="comment"># 第二层relu</span></div><div class="line">predictions = Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)(x) <span class="comment"># 输出层</span></div><div class="line"></div><div class="line">model = Model(inputs=inputs, outputs=predictions)</div><div class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'categorical_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</div><div class="line">model.fit(data,labels)</div></pre></td></tr></table></figure><h2 id="模型通用方法"><a href="#模型通用方法" class="headerlink" title="模型通用方法"></a>模型通用方法</h2><p><code>model.summary()</code>:打印模型概况</p><p><code>model.get_config()</code>:返回包含模型配置信息的字典</p><p><code>model.get_layer()</code>:根据层名称或者下标获取层对象</p><p><code>model.set_weights()</code>:为模型赋予权重</p><p><code>model.to_json</code>:返回模型的json字符串，仅包含网络结构，不保全权重</p><p><code>model.save_weights(filepath)</code>：将模型权重保存到指定路径，文件类型是HDF5（后缀是.h5）。</p><p><code>model.load_weights(filepath, by_name=False)</code>：从HDF5文件中加载权重到当前模型中, 默认情况下模型的结构将保持不变。如果想将权重载入不同的模型（有些层相同）中，则设置<code>by_name=True</code>，只有名字匹配的层才会载入权重。</p><h2 id="Sequential模型方法"><a href="#Sequential模型方法" class="headerlink" title="Sequential模型方法"></a>Sequential模型方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add(self, layer)</div></pre></td></tr></table></figure><p>向模型中添加一个层</p><ul><li>layer: Layer对象</li></ul><hr><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pop(self)</div></pre></td></tr></table></figure><p>弹出模型最后的一层，无返回值</p><hr><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(self, optimizer, loss, metrics=<span class="keyword">None</span>, sample_weight_mode=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>编译用来配置模型的学习过程，其参数有</p><ul><li>optimizer：字符串（预定义优化器名）或优化器对象，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/optimizers/" target="_blank" rel="external">优化器</a></li><li>loss：字符串（预定义损失函数名）或目标函数，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/objectives/" target="_blank" rel="external">损失函数</a></li><li>metrics：列表，包含评估模型在训练和测试时的网络性能的指标，典型用法是<code>metrics=[&#39;accuracy&#39;]</code></li><li>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。在下面<code>fit</code>函数的解释中有相关的参考内容。</li><li>kwargs：使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.add(Dense(<span class="number">32</span>, input_shape=(<span class="number">500</span>,)))</div><div class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</div><div class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</div><div class="line">      loss=<span class="string">'categorical_crossentropy'</span>,</div><div class="line">      metrics=[<span class="string">'accuracy'</span>])</div></pre></td></tr></table></figure><p>模型在使用前必须编译，否则在调用fit或evaluate时会抛出异常。</p><h3 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit(self, x, y, batch_size=<span class="number">32</span>, epochs=<span class="number">10</span>, verbose=<span class="number">1</span>, callbacks=<span class="keyword">None</span>, validation_split=<span class="number">0.0</span>, validation_data=<span class="keyword">None</span>, shuffle=<span class="keyword">True</span>, class_weight=<span class="keyword">None</span>, sample_weight=<span class="keyword">None</span>, initial_epoch=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>本函数将模型训练<code>nb_epoch</code>轮，其参数有：</p><ul><li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array</li><li>y：标签，numpy array</li><li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li><li>epochs：整数，训练的轮数，每个epoch会把训练集轮一遍。</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>callbacks：list，其中的元素是<code>keras.callbacks.Callback</code>的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/" target="_blank" rel="external">回调函数</a></li><li>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之前，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。</li><li>validation_data：形式为（X，y）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li><li>shuffle：布尔值或字符串，一般为布尔值，表示是否在训练过程中随机打乱输入样本的顺序。若为字符串“batch”，则是用来处理HDF5数据的特殊情况，它将在batch内部将数据打乱。</li><li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p><code>fit</code>函数返回一个<code>History</code>的对象，其<code>History.history</code>属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况</p><hr><p>evaluate</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate(self, x, y, batch_size=<span class="number">32</span>, verbose=<span class="number">1</span>, sample_weight=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>本函数按batch计算在某些输入数据上模型的误差，其参数有：</p><ul><li>x：输入数据，与<code>fit</code>一样，是numpy array或numpy array的list</li><li>y：标签，numpy array</li><li>batch_size：整数，含义同<code>fit</code>的同名参数</li><li>verbose：含义同<code>fit</code>的同名参数，但只能取0或1</li><li>sample_weight：numpy array，含义同<code>fit</code>的同名参数</li></ul><p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。<code>model.metrics_names</code>将给出list中各个值的含义。</p><p>如果没有特殊说明，以下函数的参数均保持与<code>fit</code>的同名参数相同的含义</p><p>如果没有特殊说明，以下函数的verbose参数（如果有）均只能取0或1</p><hr><h3 id="predict"><a href="#predict" class="headerlink" title="predict"></a>predict</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict(self, x, batch_size=<span class="number">32</span>, verbose=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>本函数按batch获得输入数据对应的输出，其参数有：</p><p>函数的返回值是预测值的numpy array</p><hr><h3 id="train-on-batch"><a href="#train-on-batch" class="headerlink" title="train_on_batch"></a>train_on_batch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train_on_batch(self, x, y, class_weight=<span class="keyword">None</span>, sample_weight=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>本函数在一个batch的数据上进行一次参数更新</p><p>函数返回训练误差的标量值或标量值的list，与<a href="https://keras-cn.readthedocs.io/en/latest/models/sequential/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同。</p><hr><h3 id="test-on-batch"><a href="#test-on-batch" class="headerlink" title="test_on_batch"></a>test_on_batch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test_on_batch(self, x, y, sample_weight=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行评估</p><p>函数的返回与<a href="https://keras-cn.readthedocs.io/en/latest/models/sequential/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同</p><hr><h3 id="predict-on-batch"><a href="#predict-on-batch" class="headerlink" title="predict_on_batch"></a>predict_on_batch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict_on_batch(self, x)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行测试</p><p>函数返回模型在一个batch上的预测结果</p><hr><h3 id="fit-generator"><a href="#fit-generator" class="headerlink" title="fit_generator"></a>fit_generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit_generator(self, generator, steps_per_epoch, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, callbacks=<span class="keyword">None</span>, validation_data=<span class="keyword">None</span>, validation_steps=<span class="keyword">None</span>, class_weight=<span class="keyword">None</span>, max_q_size=<span class="number">10</span>, workers=<span class="number">1</span>, pickle_safe=<span class="keyword">False</span>, initial_epoch=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>利用Python的生成器，逐个生成数据的batch并进行训练。生成器与模型将并行执行以提高效率。例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练</p><p>函数的参数是：</p><ul><li>generator：生成器函数，生成器的输出应该为：<ul><li>一个形如（inputs，targets）的tuple</li><li>一个形如（inputs, targets,sample_weight）的tuple。所有的返回值都应该包含相同数目的样本。生成器将无限在数据集上循环。每个epoch以经过模型的样本数达到<code>samples_per_epoch</code>时，记一个epoch结束</li></ul></li><li>steps_per_epoch：整数，当生成器返回<code>steps_per_epoch</code>次数据时计一个epoch结束，执行下一个epoch</li><li>epochs：整数，数据迭代的轮数</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>validation_data：具有以下三种形式之一<ul><li>生成验证集的生成器</li><li>一个形如（inputs,targets）的tuple</li><li>一个形如（inputs,targets，sample_weights）的tuple</li></ul></li><li>validation_steps: 当validation_data为生成器时，本参数指定验证集的生成器返回次数</li><li>class_weight：规定类别权重的字典，将类别映射为权重，常用于处理样本不均衡问题。</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>workers：最大进程数</li><li>max_q_size：生成器队列的最大容量</li><li>pickle_safe: 若为真，则使用基于进程的线程。由于该实现依赖多进程，不能传递non picklable（无法被pickle序列化）的参数到生成器中，因为无法轻易将它们传入子进程中。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p>函数返回一个<code>History</code>对象</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_arrays_from_file</span><span class="params">(path)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">            f = open(path)</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                <span class="comment"># create Numpy arrays of input data</span></div><div class="line">                <span class="comment"># and labels, from each line in the file</span></div><div class="line">                x, y = process_line(line)</div><div class="line">                <span class="keyword">yield</span> (x, y)</div><div class="line">        f.close()</div><div class="line"></div><div class="line">model.fit_generator(generate_arrays_from_file(<span class="string">'/my_file.txt'</span>),</div><div class="line">        samples_per_epoch=<span class="number">10000</span>, epochs=<span class="number">10</span>)</div></pre></td></tr></table></figure><hr><h3 id="evaluate-generator"><a href="#evaluate-generator" class="headerlink" title="evaluate_generator"></a>evaluate_generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate_generator(self, generator, steps, max_q_size=<span class="number">10</span>, workers=<span class="number">1</span>, pickle_safe=<span class="keyword">False</span>)</div></pre></td></tr></table></figure><p>本函数使用一个生成器作为数据源评估模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。该函数的参数与<code>fit_generator</code>同名参数含义相同，steps是生成器要返回数据的轮数。</p><hr><h3 id="predcit-generator"><a href="#predcit-generator" class="headerlink" title="predcit_generator"></a>predcit_generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict_generator(self, generator, steps, max_q_size=<span class="number">10</span>, workers=<span class="number">1</span>, pickle_safe=<span class="keyword">False</span>, verbose=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>本函数使用一个生成器作为数据源预测模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。该函数的参数与<code>fit_generator</code>同名参数含义相同，steps是生成器要返回数据的轮数。</p><h2 id="函数式模型接口"><a href="#函数式模型接口" class="headerlink" title="函数式模型接口"></a>函数式模型接口</h2><p>Keras的函数式模型为<code>Model</code>，即广义的拥有输入和输出的模型，我们使用<code>Model</code>来初始化一个函数式模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from keras.models import Model</div><div class="line">from keras.layers import Input, Dense</div><div class="line"></div><div class="line">a = Input(shape=(32,))</div><div class="line">b = Dense(32)(a)</div><div class="line">model = Model(inputs=a, outputs=b)</div></pre></td></tr></table></figure><p>在这里，我们的模型以<code>a</code>为输入，以<code>b</code>为输出，同样我们可以构造拥有多输入和多输出的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model = Model(inputs=[a1, a2], outputs=[b1, b3, b3])</div></pre></td></tr></table></figure><hr><h3 id="Model模型方法"><a href="#Model模型方法" class="headerlink" title="Model模型方法"></a>Model模型方法</h3><h3 id="compile-1"><a href="#compile-1" class="headerlink" title="compile"></a>compile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(self, optimizer, loss, metrics=None, loss_weights=None, sample_weight_mode=None)</div></pre></td></tr></table></figure><p>本函数编译模型以供训练，参数有</p><ul><li>optimizer：优化器，为预定义优化器名或优化器对象，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/optimizers/" target="_blank" rel="external">优化器</a></li><li>loss：损失函数，为预定义损失函数名或一个目标函数，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/objectives/" target="_blank" rel="external">损失函数</a></li><li>metrics：列表，包含评估模型在训练和测试时的性能的指标，典型用法是<code>metrics=[&#39;accuracy&#39;]</code>如果要在多输出模型中为不同的输出指定不同的指标，可像该参数传递一个字典，例如<code>metrics={&#39;ouput_a&#39;: &#39;accuracy&#39;}</code></li><li>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。如果模型有多个输出，可以向该参数传入指定sample_weight_mode的字典或列表。在下面<code>fit</code>函数的解释中有相关的参考内容。</li><li>kwargs：使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function</li></ul><p>当为参数传入非法值时会抛出异常</p><p>【Tips】如果你只是载入模型并利用其predict，可以不用进行compile。在Keras中，compile主要完成损失函数和优化器的一些配置，是为训练服务的。predict会在内部进行符号函数的编译工作（通过调用_make_predict_function生成函数），</p><hr><h3 id="fit-1"><a href="#fit-1" class="headerlink" title="fit"></a>fit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit(self, x=None, y=None, batch_size=32, epochs=1, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0)</div></pre></td></tr></table></figure><p>本函数用以训练模型，参数有：</p><ul><li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array。如果模型的每个输入都有名字，则可以传入一个字典，将输入名与其输入数据对应起来。</li><li>y：标签，numpy array。如果模型有多个输出，可以传入一个numpy array的list。如果模型的输出拥有名字，则可以传入一个字典，将输出名与其标签对应起来。</li><li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li><li>nb_epoch：整数，训练的轮数，训练数据将会被遍历nb_epoch次。Keras中nb开头的变量均为”number of”的意思</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>callbacks：list，其中的元素是<code>keras.callbacks.Callback</code>的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/" target="_blank" rel="external">回调函数</a></li><li>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之后，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。</li><li>validation_data：形式为（X，y）或（X，y，sample_weights）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li><li>shuffle：布尔值，表示是否在训练过程中每个epoch前随机打乱输入样本的顺序。</li><li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）。该参数在处理非平衡的训练数据（某些类的训练样本数很少）时，可以使得损失函数对样本数不足的数据更加关注。</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p>输入数据与规定数据不匹配时会抛出错误</p><p><code>fit</code>函数返回一个<code>History</code>的对象，其<code>History.history</code>属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况</p><hr><p>evaluate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate(self, x, y, batch_size=32, verbose=1, sample_weight=None)</div></pre></td></tr></table></figure><p>本函数按batch计算在某些输入数据上模型的误差，其参数有：</p><ul><li>x：输入数据，与<code>fit</code>一样，是numpy array或numpy array的list</li><li>y：标签，numpy array</li><li>batch_size：整数，含义同<code>fit</code>的同名参数</li><li>verbose：含义同<code>fit</code>的同名参数，但只能取0或1</li><li>sample_weight：numpy array，含义同<code>fit</code>的同名参数</li></ul><p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。<code>model.metrics_names</code>将给出list中各个值的含义。</p><p>如果没有特殊说明，以下函数的参数均保持与<code>fit</code>的同名参数相同的含义</p><p>如果没有特殊说明，以下函数的verbose参数（如果有）均只能取0或1</p><hr><h3 id="predict-1"><a href="#predict-1" class="headerlink" title="predict"></a>predict</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict(self, x, batch_size=32, verbose=0)</div></pre></td></tr></table></figure><p>本函数按batch获得输入数据对应的输出，其参数有：</p><p>函数的返回值是预测值的numpy array</p><hr><h3 id="train-on-batch-1"><a href="#train-on-batch-1" class="headerlink" title="train_on_batch"></a>train_on_batch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train_on_batch(self, x, y, class_weight=None, sample_weight=None)</div></pre></td></tr></table></figure><p>本函数在一个batch的数据上进行一次参数更新</p><p>函数返回训练误差的标量值或标量值的list，与<a href="https://keras-cn.readthedocs.io/en/latest/models/model/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同。</p><hr><h3 id="test-on-batch-1"><a href="#test-on-batch-1" class="headerlink" title="test_on_batch"></a>test_on_batch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test_on_batch(self, x, y, sample_weight=None)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行评估</p><p>函数的返回与<a href="https://keras-cn.readthedocs.io/en/latest/models/model/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同</p><hr><h3 id="predict-on-batch-1"><a href="#predict-on-batch-1" class="headerlink" title="predict_on_batch"></a>predict_on_batch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict_on_batch(self, x)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行测试</p><p>函数返回模型在一个batch上的预测结果</p><hr><h3 id="fit-generator-1"><a href="#fit-generator-1" class="headerlink" title="fit_generator"></a>fit_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)</div></pre></td></tr></table></figure><p>利用Python的生成器，逐个生成数据的batch并进行训练。生成器与模型将并行执行以提高效率。例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练</p><p>函数的参数是：</p><ul><li>generator：生成器函数，生成器的输出应该为：<ul><li>一个形如（inputs，targets）的tuple</li><li>一个形如（inputs, targets,sample_weight）的tuple。所有的返回值都应该包含相同数目的样本。生成器将无限在数据集上循环。每个epoch以经过模型的样本数达到<code>samples_per_epoch</code>时，记一个epoch结束</li></ul></li><li>steps_per_epoch：整数，当生成器返回<code>steps_per_epoch</code>次数据时计一个epoch结束，执行下一个epoch</li><li>epochs：整数，数据迭代的轮数</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>validation_data：具有以下三种形式之一<ul><li>生成验证集的生成器</li><li>一个形如（inputs,targets）的tuple</li><li>一个形如（inputs,targets，sample_weights）的tuple</li></ul></li><li>validation_steps: 当validation_data为生成器时，本参数指定验证集的生成器返回次数</li><li>class_weight：规定类别权重的字典，将类别映射为权重，常用于处理样本不均衡问题。</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>workers：最大进程数</li><li>max_q_size：生成器队列的最大容量</li><li>pickle_safe: 若为真，则使用基于进程的线程。由于该实现依赖多进程，不能传递non picklable（无法被pickle序列化）的参数到生成器中，因为无法轻易将它们传入子进程中。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p>函数返回一个<code>History</code>对象</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def generate_arrays_from_file(path):</div><div class="line">    while 1:</div><div class="line">    f = open(path)</div><div class="line">    for line in f:</div><div class="line">        # create numpy arrays of input data</div><div class="line">        # and labels, from each line in the file</div><div class="line">        x1, x2, y = process_line(line)</div><div class="line">        yield (&#123;&apos;input_1&apos;: x1, &apos;input_2&apos;: x2&#125;, &#123;&apos;output&apos;: y&#125;)</div><div class="line">    f.close()</div><div class="line"></div><div class="line">model.fit_generator(generate_arrays_from_file(&apos;/my_file.txt&apos;),</div><div class="line">        steps_per_epoch=10000, epochs=10)</div></pre></td></tr></table></figure><hr><h3 id="evaluate-generator-1"><a href="#evaluate-generator-1" class="headerlink" title="evaluate_generator"></a>evaluate_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False)</div></pre></td></tr></table></figure><p>本函数使用一个生成器作为数据源，来评估模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。</p><p>函数的参数是：</p><ul><li>generator：生成输入batch数据的生成器</li><li>val_samples：生成器应该返回的总样本数</li><li>steps：生成器要返回数据的轮数</li><li>max_q_size：生成器队列的最大容量</li><li>nb_worker：使用基于进程的多线程处理时的进程数</li><li>pickle_safe：若设置为True，则使用基于进程的线程。注意因为它的实现依赖于多进程处理，不可传递不可pickle的参数到生成器中，因为它们不能轻易的传递到子进程中。</li></ul><hr><h3 id="predict-generator"><a href="#predict-generator" class="headerlink" title="predict_generator"></a>predict_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)</div></pre></td></tr></table></figure><p>从一个生成器上获取数据并进行预测，生成器应返回与<code>predict_on_batch</code>输入类似的数据</p><p>函数的参数是：</p><ul><li><p>generator：生成输入batch数据的生成器</p></li><li><p>val_samples：生成器应该返回的总样本数</p></li><li><p>max_q_size：生成器队列的最大容量</p></li><li><p>nb_worker：使用基于进程的多线程处理时的进程数</p></li><li><p>pickle_safe：若设置为True，则使用基于进程的线程。注意因为它的实现依赖于多进程处理，不可传递不可pickle的参数到生成器中，因为它们不能轻易的传递到子进程中。</p></li></ul><hr><h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><h2 id="1、常用层core"><a href="#1、常用层core" class="headerlink" title="1、常用层core"></a>1、常用层core</h2><p>常用层对应于core模块，core内部定义了一系列常用的网络层，包括全连接、激活层等</p><h3 id="Dense层"><a href="#Dense层" class="headerlink" title="Dense层"></a>Dense层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Dense(units, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>Dense就是常用的全连接层，所实现的运算是<code>output = activation(dot(input, kernel)+bias)</code>。其中<code>activation</code>是逐元素计算的激活函数，<code>kernel</code>是本层的权值矩阵，<code>bias</code>为偏置向量，只有当<code>use_bias=True</code>才会添加。</p><p>如果本层的输入数据的维度大于2，则会先被压为与<code>kernel</code>相匹配的大小。</p><p>参数含义如下：</p><ul><li>units：大于0的整数，代表该层的输出维度。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>use_bias: 布尔值，是否使用偏置项</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="Activation层"><a href="#Activation层" class="headerlink" title="Activation层"></a>Activation层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Activation(activation)</div></pre></td></tr></table></figure><p>激活层对一个层的输出施加激活函数</p><p>参数</p><ul><li>activation：将要使用的激活函数，为预定义激活函数名或一个Tensorflow/Theano的函数。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a></li></ul><p>输入shape：任意，当使用激活层作为第一层时，要指定<code>input_shape</code></p><p>输出shape：与输入shape相同</p><h3 id="Dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Dropout(rate, noise_shape=None, seed=None)</div></pre></td></tr></table></figure><p>为输入数据施加Dropout。Dropout将在训练过程中每次更新参数时按一定概率（rate）随机断开输入神经元，Dropout层用于防止过拟合。</p><p>参数</p><ul><li>rate：0~1的浮点数，控制需要断开的神经元的比例</li><li>noise_shape：整数张量，为将要应用在输入上的二值Dropout mask的shape，例如你的输入为(batch_size, timesteps, features)，并且你希望在各个时间步上的Dropout mask都相同，则可传入noise_shape=(batch_size, 1, features)。</li><li>seed：整数，使用的随机数种子</li></ul><h3 id="Flatten层"><a href="#Flatten层" class="headerlink" title="Flatten层"></a>Flatten层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Flatten()</div></pre></td></tr></table></figure><p>Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.add(Convolution2D(64, 3, 3,</div><div class="line">            border_mode=&apos;same&apos;,</div><div class="line">            input_shape=(3, 32, 32)))</div><div class="line"># now: model.output_shape == (None, 64, 32, 32)</div><div class="line"></div><div class="line">model.add(Flatten())</div><div class="line"># now: model.output_shape == (None, 65536)</div></pre></td></tr></table></figure><h3 id="Reshape层"><a href="#Reshape层" class="headerlink" title="Reshape层"></a>Reshape层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Reshape(target_shape)</div></pre></td></tr></table></figure><p>Reshape层用来将输入shape转换为特定的shape</p><p>参数</p><ul><li><p>target_shape：目标shape，为整数的tuple，不包含样本数目的维度（batch大小）</p><p>输入shape:任意，但输入的shape必须固定。当使用该层为模型首层时，需要指定<code>input_shape</code>参数</p></li></ul><p>输出shape:<code>(batch_size,)+target_shape</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># as first layer in a Sequential model</div><div class="line">model = Sequential()</div><div class="line">model.add(Reshape((3, 4), input_shape=(12,)))</div><div class="line"># now: model.output_shape == (None, 3, 4)</div><div class="line"># note: `None` is the batch dimension</div><div class="line"></div><div class="line"># as intermediate layer in a Sequential model</div><div class="line">model.add(Reshape((6, 2)))</div><div class="line"># now: model.output_shape == (None, 6, 2)</div><div class="line"></div><div class="line"># also supports shape inference using `-1` as dimension</div><div class="line">model.add(Reshape((-1, 2, 2)))</div><div class="line"># now: model.output_shape == (None, 3, 2, 2)</div></pre></td></tr></table></figure><p>###Permute层<br>将输入的维度按照给定的模式进行重排。</p><p>###RepeatVector层<br>将输入层重复n次。</p><p>###Lambda层<br>对上一层的输出施以某个表达式。</p><p>###ActivityRegularizer层<br>经过本层的数据不会有任何变化，但会基于其激活值更新损失函数值。<br>参数：<br>l1：1范数正则因子（正浮点数）<br>l2：2范数正则因子（正浮点数）<br>输入shape：任意，当使用该层作为第一层时，要指定input_shape<br>输出shape：与输入shape相同</p><p>###Masking层<br>使用给定的值对输入的序列信号进行“屏蔽”，用以定位需要跳过的时间步</p><h2 id="2、卷积层"><a href="#2、卷积层" class="headerlink" title="2、卷积层"></a>2、卷积层</h2><h3 id="Conv1D层"><a href="#Conv1D层" class="headerlink" title="Conv1D层"></a><strong>Conv1D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv1D(filters, kernel_size, strides=<span class="number">1</span>, padding=<span class="string">'valid'</span>, dilation_rate=<span class="number">1</span>, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>一维卷积层（即时域卷积），用以在一维输入信号上进行邻域滤波。当使用该层作为首层时，需要提供关键字参数<code>input_shape</code>。例如<code>(10,128)</code>代表一个长为10的序列，序列中每个信号为128向量。而<code>(None, 128)</code>代表变长的128维向量序列。</p><p>该层生成将输入信号与卷积核按照单一的空域（或时域）方向进行卷积。如果<code>use_bias=True</code>，则还会加上一个偏置项，若<code>activation</code>不为None，则输出为经过激活函数的输出。</p><p>参数</p><ul><li>filters：卷积核的数目（即输出的维度）</li><li>kernel_size：整数或由单个整数构成的list/tuple，卷积核的空域或时域窗长度</li><li>strides：整数或由单个整数构成的list/tuple，为卷积的步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li><li>padding：补0策略，为“valid”, “same” 或“causal”，“causal”将产生因果（膨胀的）卷积，即output[t]不依赖于input[t+1：]。当对不能违反时间顺序的时序信号建模时有用。参考<a href="https://arxiv.org/abs/1609.03499" target="_blank" rel="external">WaveNet: A Generative Model for Raw Audio, section 2.1.</a>。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>dilation_rate：整数或由单个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li><li>use_bias:布尔值，是否使用偏置项</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="Conv2D层"><a href="#Conv2D层" class="headerlink" title="Conv2D层"></a><strong>Conv2D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv2D(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, dilation_rate=(<span class="number">1</span>, <span class="number">1</span>), activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>二维卷积层，即对图像的空域卷积。该层对二维输入进行滑动窗卷积，当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (128,128,3)</code>代表128*128的彩色RGB图像（<code>data_format=&#39;channels_last&#39;</code>）</p><p>参数</p><ul><li>filters：卷积核的数目（即输出的维度）</li><li>kernel_size：单个整数或由两个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li><li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li><li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>dilation_rate：单个整数或由两个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li><li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是<code>~/.keras/keras.json</code>中设置的值，若从未设置过，则为“channels_last”。</li><li>use_bias:布尔值，是否使用偏置项</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="SeparableConv2D层"><a href="#SeparableConv2D层" class="headerlink" title="SeparableConv2D层"></a><strong>SeparableConv2D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.SeparableConv2D(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, depth_multiplier=<span class="number">1</span>, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, depthwise_initializer=<span class="string">'glorot_uniform'</span>, pointwise_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, depthwise_regularizer=<span class="keyword">None</span>, pointwise_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, depthwise_constraint=<span class="keyword">None</span>, pointwise_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>该层是在深度方向上的可分离卷积。</p><p>可分离卷积首先按深度方向进行卷积（对每个输入通道分别卷积），然后逐点进行卷积，将上一步的卷积结果混合到输出通道中。参数<code>depth_multiplier</code>控制了在depthwise卷积（第一步）的过程中，每个输入通道信号产生多少个输出通道。</p><p>直观来说，可分离卷积可以看做讲一个卷积核分解为两个小的卷积核，或看作Inception模块的一种极端情况。</p><p>当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (3,128,128)</code>代表128*128的彩色RGB图像</p><p>参数</p><ul><li>filters：卷积核的数目（即输出的维度）</li><li>kernel_size：单个整数或由两个个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li><li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li><li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>dilation_rate：单个整数或由两个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li><li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是<code>~/.keras/keras.json</code>中设置的值，若从未设置过，则为“channels_last”。</li><li>use_bias:布尔值，是否使用偏置项</li><li>depth_multiplier：在按深度卷积的步骤中，每个输入通道使用多少个输出通道</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>depthwise_regularizer：施加在按深度卷积的权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>pointwise_regularizer：施加在按点卷积的权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>depthwise_constraint：施加在按深度卷积权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>pointwise_constraint施加在按点卷积权重的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="Conv2DTranspos层"><a href="#Conv2DTranspos层" class="headerlink" title="Conv2DTranspos层"></a><strong>Conv2DTranspos层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv2DTranspose(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>该层是转置的卷积操作（反卷积）。需要反卷积的情况通常发生在用户想要对一个普通卷积的结果做反方向的变换。例如，将具有该卷积层输出shape的tensor转换为具有该卷积层输入shape的tensor。同时保留与卷积层兼容的连接模式。</p><p>当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (3,128,128)</code>代表128*128的彩色RGB图像</p><h3 id="Conv3D层"><a href="#Conv3D层" class="headerlink" title="Conv3D层"></a><strong>Conv3D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv3D(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, dilation_rate=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>三维卷积对三维的输入进行滑动窗卷积，当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (3,10,128,128)</code>代表对10帧128*128的彩色RGB图像进行卷积。数据的通道位置仍然有<code>data_format</code>参数指定。</p><h3 id="Cropping1D层"><a href="#Cropping1D层" class="headerlink" title="Cropping1D层"></a><strong>Cropping1D层</strong></h3><p>在时间轴（axis1）上对1D输入（即时间序列）进行裁剪</p><h3 id="Cropping2D层"><a href="#Cropping2D层" class="headerlink" title="Cropping2D层"></a><strong>Cropping2D层</strong></h3><p>对2D输入（图像）进行裁剪，将在空域维度，即宽和高的方向上裁剪</p><h3 id="Cropping3D层"><a href="#Cropping3D层" class="headerlink" title="Cropping3D层"></a><strong>Cropping3D层</strong></h3><p>对2D输入（图像）进行裁剪</p><h3 id="UpSampling1D层"><a href="#UpSampling1D层" class="headerlink" title="UpSampling1D层"></a><strong>UpSampling1D层</strong></h3><p>在时间轴上，将每个时间步重复<code>length</code>次</p><h3 id="UpSampling2D层"><a href="#UpSampling2D层" class="headerlink" title="UpSampling2D层"></a><strong>UpSampling2D层</strong></h3><p>将数据的行和列分别重复size[0]和size[1]次</p><h3 id="UpSampling3D层"><a href="#UpSampling3D层" class="headerlink" title="UpSampling3D层"></a><strong>UpSampling3D层</strong></h3><p>将数据的三个维度上分别重复size[0]、size[1]和ize[2]次</p><h3 id="ZeroPadding2D层"><a href="#ZeroPadding2D层" class="headerlink" title="ZeroPadding2D层"></a><strong>ZeroPadding2D层</strong></h3><p>对2D输入（如图片）的边界填充0，以控制卷积以后特征图的大小</p><h3 id="ZeroPadding3D层"><a href="#ZeroPadding3D层" class="headerlink" title="ZeroPadding3D层"></a><strong>ZeroPadding3D层</strong></h3><p>对3个维度填充0，以控制卷积以后特征图的大小</p><h2 id="3、池化层"><a href="#3、池化层" class="headerlink" title="3、池化层"></a>3、池化层</h2><p><strong>MaxPooling1D层</strong>：对时域1D的信号进行最大值池化</p><p><strong>MaxPooling2D层</strong>：对空域1D的信号进行最大值池化</p><p><strong>MaxPooling3D层</strong>：对3D的信号进行最大值池化，本层目前只能在使用Theano为后端时可用</p><p><strong>AveragePooling1D层</strong>：对时域1D的信号进行平均值池化</p><p><strong>AveragePooling1D层</strong>：对时域1D的信号进行平均值池化</p><p><strong>AveragePooling1D层</strong>：对时域1D的信号进行平均值池化，本层目前只能在使用Theano为后端时可用</p><h2 id="4、局部连接层LocallyConnected"><a href="#4、局部连接层LocallyConnected" class="headerlink" title="4、局部连接层LocallyConnected"></a>4、局部连接层LocallyConnected</h2><p><strong>LocallyConnected1D层</strong>：<code>LocallyConnected1D</code>层与<code>Conv1D</code>工作方式类似，唯一的区别是不进行权值共享。即施加在不同输入位置的滤波器是不一样的。</p><p><strong>LocallyConnected2D层</strong>：<code>LocallyConnected2D</code>层与<code>Convolution2D</code>工作方式类似，唯一的区别是不进行权值共享。即施加在不同输入patch的滤波器是不一样的，当使用该层作为模型首层时，需要提供参数<code>input_dim</code>或<code>input_shape</code>参数。参数含义参考<code>Convolution2D</code>。</p><h2 id="5、循环层Recurrent"><a href="#5、循环层Recurrent" class="headerlink" title="5、循环层Recurrent"></a>5、循环层Recurrent</h2><p><strong>Recurrent层</strong></p><p>这是循环层的抽象类，请不要在模型中直接应用该层（因为它是抽象类，无法实例化任何对象）。请使用它的子类<code>LSTM</code>，<code>GRU</code>或<code>SimpleRNN</code>。</p><p><strong>SimpleRNN层</strong></p><p>全连接RNN网络，RNN的输出会被回馈到输入</p><h1 id="三、数据预处理"><a href="#三、数据预处理" class="headerlink" title="三、数据预处理"></a>三、数据预处理</h1><h1 id="四、网络配置"><a href="#四、网络配置" class="headerlink" title="四、网络配置"></a>四、网络配置</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://keras.io/" target="_blank" rel="external">官方文档(英文)</a></li><li><a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="external">官方文档(中文)</a></li><li><a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf" target="_blank" rel="external">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Keras是一个用Python编写的、高度封装的、支持Tensorflow、CNTK、Theano的神经网络库。&lt;/p&gt;
&lt;h1 id=&quot;一
      
    
    </summary>
    
    
      <category term="Keras    机器学习   人工智能" scheme="http://yoursite.com/tags/Keras-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo学习笔记</title>
    <link href="http://yoursite.com/2017/11/05/Hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/05/Hexo学习笔记/</id>
    <published>2017-11-05T08:42:30.000Z</published>
    <updated>2017-11-13T12:47:45.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo学习笔记"><a href="#Hexo学习笔记" class="headerlink" title="Hexo学习笔记"></a>Hexo学习笔记</h1><blockquote><p>Hexo是一个快速简洁的博客框架，使用Markdown解析文章，将内容生成静态网页，配合主题可以制作成精美的网页，将网页部署到github之后，你就有了一个免费的博客</p></blockquote><p>个人感觉，面向开发者而言，博客应该是记录自己点滴积累的地方，它应该足够简洁，不应该有广告等元素干扰阅读，它应该是开发友好的，对程序员而言保持双手在键盘上，给我们顺滑流畅的书写过程，最后它应该足够强大，能让我们充分折腾，如何你也有这样的想法，那么<code>Hexo</code>是一个十分不错的选择。</p><p>本文档将按照官方文档的结构顺序从头到尾从网站初始化到部署到github完整的一个流程进行详细的说明。</p><h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># step1、安装Node.js</span></div><div class="line">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</div><div class="line"><span class="comment"># 安装完成后，重启终端并执行下列命令即可安装 Node.js</span></div><div class="line">nvm install stable    </div><div class="line"></div><div class="line"><span class="comment"># step2、安装github</span></div><div class="line">sudo apt-get install git    </div><div class="line"></div><div class="line"><span class="comment"># step3、安装hexo</span></div><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure><h1 id="二、建站"><a href="#二、建站" class="headerlink" title="二、建站"></a>二、建站</h1><p>初始化一个空站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init &lt;folder&gt;</div><div class="line"><span class="built_in">cd</span> &lt;folder&gt;</div><div class="line">npm install</div></pre></td></tr></table></figure><p>初始化后的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml    <span class="comment"># 网站配置信息</span></div><div class="line">├── package.json<span class="comment"># 应用配置信息</span></div><div class="line">├── scaffolds<span class="comment"># 模板文件夹</span></div><div class="line">├── <span class="built_in">source</span><span class="comment"># 资源文件夹</span></div><div class="line">|   ├── _drafts<span class="comment"># 未发布的草稿内容</span></div><div class="line">|   └── _posts<span class="comment"># 已发布的博客文章</span></div><div class="line">└── themes<span class="comment"># 网站主题文件夹</span></div></pre></td></tr></table></figure><h2 id="2-1、常用命令"><a href="#2-1、常用命令" class="headerlink" title="2.1、常用命令"></a>2.1、常用命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新建一个网站</span></div><div class="line">hexo init [folder]    </div><div class="line"></div><div class="line"><span class="comment"># 新建一篇文章，如果不设置layout样式文件，则使用默认的配置，标题推荐用引号包起来(避免空格的问题)</span></div><div class="line">hexo new [layout] &lt;title&gt;    </div><div class="line"></div><div class="line"><span class="comment"># 生成静态文件，可选参数：</span></div><div class="line"><span class="comment"># -d，--deploy生成后部署网站</span></div><div class="line"><span class="comment"># -w，--watch监视文件变动</span></div><div class="line">hexo generate    </div><div class="line"></div><div class="line"><span class="comment"># 发布文章</span></div><div class="line">hexo publish [layout] &lt;filename&gt;</div><div class="line"></div><div class="line"><span class="comment"># 启动本地服务器，默认http://localhost:4000,参数：</span></div><div class="line"><span class="comment"># -p, --port重设端口</span></div><div class="line"><span class="comment"># -s, --static只使用静态文件</span></div><div class="line"><span class="comment"># -l, --log启动日志</span></div><div class="line">hexo server</div><div class="line"></div><div class="line"><span class="comment"># 部署网站，可选参数：</span></div><div class="line"><span class="comment"># -g,--generate部署之前预先生成静态文件</span></div><div class="line">hexo deploy</div><div class="line"></div><div class="line"><span class="comment"># 渲染文件，可选参数</span></div><div class="line"><span class="comment"># -o,--output设置输出路径</span></div><div class="line">hexo render &lt;file1&gt; [file2] ...</div><div class="line"></div><div class="line"><span class="comment"># 清理缓存文件和已经生成的静态文件</span></div><div class="line">hexo clean</div><div class="line"></div><div class="line">hexo migrate &lt;type&gt;<span class="comment"># 迁移其他网站内容</span></div><div class="line">hexo list &lt;type&gt;<span class="comment"># 列出网站资料</span></div><div class="line">hexo version<span class="comment"># 查看版本</span></div><div class="line">hexo --safe<span class="comment"># 安全模式</span></div><div class="line">hexo --debug<span class="comment"># 调试模式</span></div><div class="line">hexo --silent<span class="comment"># 简洁模式</span></div><div class="line">hexo --config custom.yml<span class="comment"># 自定义配置文件路径</span></div><div class="line">hexo --draft<span class="comment"># 显示草稿</span></div><div class="line">hexo --cwd /path/to/cwd<span class="comment"># 自定义当前工作目录</span></div></pre></td></tr></table></figure><p>最后几个命令不常用，需要的时候可以参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>。</p><h2 id="2-2、config-yml文件说明"><a href="#2-2、config-yml文件说明" class="headerlink" title="2.2、config.yml文件说明"></a>2.2、config.yml文件说明</h2><p>该文件主要用来配置网站本身的信息，如域名、名称、描述等，网站初始化后会默认新建本文件，配置项目包括：网站(site)、网址(URL)、目录(Directory)、文章(Writing)、主页信息(Home page setting)、分类标签(Category &amp; Tag)、分页(Pagination)、扩展(Extensions)、部署(Deployment)。下面对这些内容结合自己的实例进行逐项说明，详细的说明可以从<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>中查询。</p><p>#### </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Hexo Configuration</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></div><div class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></div><div class="line"></div><div class="line"><span class="comment"># 网站Site</span></div><div class="line">title: FlyingFire<span class="comment"># 网站标题</span></div><div class="line">subtitle: a step further every day<span class="comment"># 网站副标题</span></div><div class="line">description:<span class="comment"># 网站描述，这边可以好好写以方便搜索引擎SEO</span></div><div class="line">author: FlyingFire<span class="comment"># 作者</span></div><div class="line">language:<span class="comment"># 网站使用的语言</span></div><div class="line">timezone:<span class="comment"># 时区，默认为当前电脑的时区</span></div><div class="line"></div><div class="line"><span class="comment"># 网址URL</span></div><div class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></div><div class="line">url: http://yoursite.com<span class="comment"># 网址</span></div><div class="line">root: /<span class="comment"># 网站根目录</span></div><div class="line">permalink: :year/:month/:day/:title/<span class="comment"># 文章永久链接格式</span></div><div class="line">permalink_defaults:<span class="comment"># 永久链接中各部分的默认值</span></div><div class="line"></div><div class="line"><span class="comment"># 目录Directory</span></div><div class="line">source_dir: source<span class="comment"># 资源文件夹</span></div><div class="line">public_dir: public<span class="comment"># 公共文件夹，用于存放生成站点的文件</span></div><div class="line">tag_dir: tags<span class="comment"># 标签文件夹</span></div><div class="line">archive_dir: archives<span class="comment"># 归档文件夹</span></div><div class="line">category_dir: categories<span class="comment"># 分类文件夹</span></div><div class="line">code_dir: downloads/code<span class="comment"># 包含代码片段的文件夹</span></div><div class="line">i18n_dir: :lang<span class="comment"># 国际化文件夹</span></div><div class="line">skip_render:<span class="comment"># 指定跳过文件的渲染</span></div><div class="line"></div><div class="line"><span class="comment"># 文章Writing</span></div><div class="line">new_post_name: :title.md<span class="comment"># 新文章名称</span></div><div class="line">default_layout: post<span class="comment"># 预设布局</span></div><div class="line">titlecase: false <span class="comment"># 将标题转换为Title Case格式(即英文单词第一个字母大写)</span></div><div class="line">external_link: true<span class="comment"># 在新链接中打开文件</span></div><div class="line">filename_case: <span class="number">0</span><span class="comment"># 讲文件名称转换为 (1) 小写或 (2) 大写</span></div><div class="line">render_drafts: false<span class="comment"># 显示草稿</span></div><div class="line">post_asset_folder: false<span class="comment"># 启动 Asset 文件夹</span></div><div class="line">relative_link: false<span class="comment"># 把链接改为与根目录的相对位址</span></div><div class="line">future: true<span class="comment"># 显示未来的文章</span></div><div class="line">highlight:<span class="comment"># 代码块的设置</span></div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line">  </div><div class="line"><span class="comment"># 主页设置Home page setting</span></div><div class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></div><div class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></div><div class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></div><div class="line">index_generator:</div><div class="line">  path: <span class="string">''</span></div><div class="line">  per_page: <span class="number">10</span><span class="comment"># 每页文章的数目 </span></div><div class="line">  order_by: -date<span class="comment"># 文章排序顺序</span></div><div class="line">  </div><div class="line"><span class="comment"># 分类标签Category &amp; Tag</span></div><div class="line">default_category: uncategorized<span class="comment"># 默认分类</span></div><div class="line">category_map:<span class="comment"># 分类别名</span></div><div class="line">tag_map:<span class="comment"># 标签别名</span></div><div class="line"></div><div class="line"><span class="comment"># 时间格式Date / Time format</span></div><div class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></div><div class="line"><span class="comment">## You can customize the date format as defined in</span></div><div class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></div><div class="line">date_format: YYYY-MM-DD<span class="comment"># 日期格式</span></div><div class="line">time_format: HH:mm:ss<span class="comment"># 时间格式</span></div><div class="line"></div><div class="line"><span class="comment"># 分页Pagination</span></div><div class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></div><div class="line">per_page: <span class="number">10</span><span class="comment"># 每页显示的文章量 (0 = 关闭分页功能)</span></div><div class="line">pagination_dir: page<span class="comment"># 分页目录</span></div><div class="line"></div><div class="line"><span class="comment"># 扩展Extensions</span></div><div class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></div><div class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></div><div class="line">theme: vexo<span class="comment"># 当前主题名称。值为false时禁用主题</span></div><div class="line"></div><div class="line"><span class="comment"># 部署Deployment</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></div><div class="line">deploy:</div><div class="line">  type: git<span class="comment"># 部署方式</span></div><div class="line">  repo: https://github.com/henan715/henan715.github.io.git  <span class="comment"># git地址</span></div></pre></td></tr></table></figure><h1 id="三、写博客"><a href="#三、写博客" class="headerlink" title="三、写博客"></a>三、写博客</h1><p>写博客有两种方法，一种是官方手册中说明的：在命令行切换到网站根目录下，执行<code>hexo new ***</code>，另一种是直接用第三方<code>Markdown</code>工具编写文档，然后拷贝到网站目录下<code>/source/_posts/</code>中，个人认为后者更容易，可以结合<code>Typora</code>软件，写起来更舒服。</p><p>这里注意，如果使用第二种方法，要在文件的头部插入一些信息，因为hexo生成的是静态的网页，需要根据文件头部的内容进行分类、显示标题等，默认情况下，格式应该如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: Hexo学习笔记</div><div class="line">date: <span class="number">2017</span><span class="number">-11</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">42</span>:<span class="number">30</span></div><div class="line">tags:</div><div class="line">---</div><div class="line"></div><div class="line">正文内容</div></pre></td></tr></table></figure><p>这些内容在hexo中称为<code>front-matter</code>信息，当前支持的类别有：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数</td><td>描述</td><td>默认值</td></tr><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章网址</td></tr></tbody></table><p>注意，只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><p>要是嫌插入麻烦，就用hexo生成文档然后用第三方编辑器打开编辑吧。</p><h3 id="3-1、资源文件夹"><a href="#3-1、资源文件夹" class="headerlink" title="3.1、资源文件夹"></a>3.1、资源文件夹</h3><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><h4 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h4><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_config.yml</div><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><h4 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h4><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img example.jpg This is an example image %&#125;</div></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h1 id="四、插件优化"><a href="#四、插件优化" class="headerlink" title="四、插件优化"></a>四、插件优化</h1><ol><li><a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="external">hexo-admin</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo学习笔记&quot;&gt;&lt;a href=&quot;#Hexo学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Hexo学习笔记&quot;&gt;&lt;/a&gt;Hexo学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Hexo是一个快速简洁的博客框架，使用Markdown解析文章，将
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/02/hello-world/"/>
    <id>http://yoursite.com/2017/11/02/hello-world/</id>
    <published>2017-11-02T14:10:25.159Z</published>
    <updated>2017-11-02T14:10:25.159Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
