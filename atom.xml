<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FlyingFire</title>
  
  <subtitle>数据挖掘、数据分析、数据运营混合体，魔都Fintech行业搬砖工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-30T06:36:15.373Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FlyingFire</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>归一化、标准化、正则化的概念、关联及差异</title>
    <link href="http://yoursite.com/2018/06/30/%E5%BD%92%E4%B8%80%E5%8C%96%E3%80%81%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%85%B3%E8%81%94%E5%8F%8A%E5%B7%AE%E5%BC%82/"/>
    <id>http://yoursite.com/2018/06/30/归一化、标准化、正则化的概念、关联及差异/</id>
    <published>2018-06-30T06:03:40.000Z</published>
    <updated>2018-06-30T06:36:15.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归一化、标准化、正则化的概念、关联及差异"><a href="#归一化、标准化、正则化的概念、关联及差异" class="headerlink" title="归一化、标准化、正则化的概念、关联及差异"></a>归一化、标准化、正则化的概念、关联及差异</h1><p>首先说明概念：</p><ul><li>归一化：指通过某种变换将数据映射到一个小范围内，一般是[-1,1]，[0,1]，其目的是将有量纲的数据变为无量纲的数据;</li><li>标准化：将数据按比例缩放，使之落入一个小的特定区间，其目的是消除分布产生的度量偏差；</li><li>正则化：正则化主要用于避免过拟合的产生和减少网络误差。</li></ul><a id="more"></a><h2 id="1、归一化"><a href="#1、归一化" class="headerlink" title="1、归一化"></a>1、归一化</h2><p>归一化是指通过某种变换，将原始数据映射到一个更小的值域范围内，如[-1,1]、[0,1]等，其目的是将有量纲的数据变换为无量纲的数据(如收入和房子的数量)，常用的归一化方法有如下几种：</p><ul><li>Min-Max归一化：</li></ul><script type="math/tex; mode=display">x_{new} = \frac{x-x_{min}}{x_{max}-x_{min}}</script><ul><li>对数归一化：</li></ul><script type="math/tex; mode=display">y=log_{10}(x)</script><ul><li>反余切函数归一化：</li></ul><script type="math/tex; mode=display">y=\frac{actan(x)^2}{\pi}</script><p>归一化会改变数据的原始分布信息，将数据变得类似圆形的分布，如下图：</p><p><img src="/images/sourceimg/daily/20180510-1.jpg" alt="20180510-1"></p><p><img src="/images/sourceimg/daily/20180510-2.jpg" alt="20180510-2"></p><p>这里来解释一下上面两张图的含义，我们寻找最优解(圆环中心)的过程实际上实在寻找使损失函数值最小的<code>theat1</code>和<code>theat2</code>，当没有归一化的时候，假设<code>theat1</code>的范围是[1,1000]，<code>theat2</code>的范围是[1,2]，这就导致损失函数中，<code>theat2</code>变动带来的影响会远远大于<code>theat1</code>的变动，因此图一中梯度的变动是非常剧烈的，而归一化之后，二者的范围都变成了[0,1]，在图二中，梯度变化更平缓，更容易收敛到最优解。</p><p>归一化之后样本会失去原始的信息，归一化之后，各个特征对目标函数的影响权重是一致的，这样做的好处在于提高了迭代求解的精度和收敛速度。</p><h2 id="2、标准化"><a href="#2、标准化" class="headerlink" title="2、标准化"></a>2、标准化</h2><p>标准化是将数据按比例缩放，使之落入一个较小的特定区间，对不同特征维度进行伸缩变换的目的是使不同度量之间的特征具有可比性，同时不改变原始数据的分布，常用的标准化方法有：</p><ul><li>Min-Max标准化：</li></ul><script type="math/tex; mode=display">y=\frac{x-x_{min}}{x_{max}-x_{min}}</script><p>该方法的缺陷是当新样本加入后可能会改变最大值最小值的，因此要重新计算。</p><ul><li>log函数标准化</li></ul><script type="math/tex; mode=display">y=\frac{log_{10}(x)}{log_{10}(x_{max})}</script><ul><li>z-score标准化</li></ul><script type="math/tex; mode=display">x_{new} = \frac{x-\mu}{\sigma}</script><p>z-score标准化方法适合属性的最大值和最小值位置的情况，或者有超出取值范围的离群数据的情况。下面的图展示了一群离散数据标准化(原图-&gt;减去均值-&gt;除以标准差)的过程：</p><img src="/2018/06/30/归一化、标准化、正则化的概念、关联及差异/20180510-4.jpg" title="图片"><p><img src="/images/sourceimg/daily/20180510-4.jpg" alt="20180510-3"></p><p>经过上述处理后，数据分布变成了均值为0、方差为1，如下图：</p><p><img src="/images/sourceimg/daily/20180510-3.jpg" alt="20180510-3"></p><p>标准化之后可以更加容易的获得参数<code>w</code>和<code>b</code>，从而打到加速收敛的效果。</p><h2 id="3、正则化"><a href="#3、正则化" class="headerlink" title="3、正则化"></a>3、正则化</h2><p>正则化的主要用途是提高模型的泛化能力，避免过拟合，以及减少网络误差，正则化的公式是：</p><script type="math/tex; mode=display">J(\omega,b) = \frac{1}{m}\sum_{i=1}^{m}L(f(x),y)+\lambda R(f)</script><p>公式中第一项是经验风险，第二项是正则项，常用的正则项有L1正则和L2正则，多用L2正则。</p><h2 id="4、相互关系"><a href="#4、相互关系" class="headerlink" title="4、相互关系"></a>4、相互关系</h2><p>归一化和标准化本质上都是一种线性变换。</p><p>我们对归一化的公式做如下变换：</p><script type="math/tex; mode=display">令\alpha = x_{max}-x_{min}，令\beta = x_{min}, 那么有 y=\frac{x-\beta}{\alpha}</script><p>可以发现这个公式和标准化的公式是类似的，当数据给定后，标准化公式中的均值和方差可以视为是常数，我们对上述公式再做变形有：</p><script type="math/tex; mode=display">\frac{x-\beta}{\alpha} = \frac{x}{\alpha} - \frac{\beta}{\alpha} = \frac{x}{\alpha} - c</script><p>转换后的公式实际上就是对向量先按比例压缩<code>a</code>再进行平移<code>c</code>，所以归一化和标准化的本质都是一种线性变换。</p><p>线性变换有很多良好的性质，其中一个是：线性变化不改变原始数据的数值排序。</p><h2 id="5、相互区别"><a href="#5、相互区别" class="headerlink" title="5、相互区别"></a>5、相互区别</h2><ul><li>归一化的缩放是仅和最大值、最小值有关；</li><li>标准化的缩放是通过方差和每个点都相关，即每个点都作出了贡献。</li></ul><p>当数据较为集中的时候，<code>a</code>更小，数据在标准化之后会更加分散，当数据较为分散的时候，<code>a</code>较大，数据在标准化之后会集中到更小的空间。</p><p>综上，在二者的选择上，我们给出如下经验：</p><ul><li>如果对输出的结果范围有要求，使用归一化；</li><li>如果数据较为稳定，不存在极端的最大最小值，使用归一化</li><li>如果特征的微小变动会引起结果的剧烈变动，使用归一化；</li><li>如果数据存在异常值和较多的噪音，使用标准化。</li></ul><h2 id="6、参考文档"><a href="#6、参考文档" class="headerlink" title="6、参考文档"></a>6、参考文档</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32619494" target="_blank" rel="external">归一化、标准化</a></li><li><a href="https://zhuanlan.zhihu.com/p/29957294" target="_blank" rel="external">归一化、标准化和正则化</a></li><li><a href="https://www.zhihu.com/question/20455227" target="_blank" rel="external">特征工程中归一化有什么作用</a></li><li><a href="https://zhuanlan.zhihu.com/p/31635022" target="_blank" rel="external">RFM建模中的: 数据标准化和归一化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;归一化、标准化、正则化的概念、关联及差异&quot;&gt;&lt;a href=&quot;#归一化、标准化、正则化的概念、关联及差异&quot; class=&quot;headerlink&quot; title=&quot;归一化、标准化、正则化的概念、关联及差异&quot;&gt;&lt;/a&gt;归一化、标准化、正则化的概念、关联及差异&lt;/h1&gt;&lt;p&gt;首先说明概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;归一化：指通过某种变换将数据映射到一个小范围内，一般是[-1,1]，[0,1]，其目的是将有量纲的数据变为无量纲的数据;&lt;/li&gt;
&lt;li&gt;标准化：将数据按比例缩放，使之落入一个小的特定区间，其目的是消除分布产生的度量偏差；&lt;/li&gt;
&lt;li&gt;正则化：正则化主要用于避免过拟合的产生和减少网络误差。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>python中property、yield等一些类说明</title>
    <link href="http://yoursite.com/2018/06/30/python%E4%B8%ADproperty%E3%80%81yield%E7%AD%89%E4%B8%80%E4%BA%9B%E7%B1%BB%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/06/30/python中property、yield等一些类说明/</id>
    <published>2018-06-30T06:02:18.000Z</published>
    <updated>2018-06-30T06:03:11.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python类的一些说明"><a href="#Python类的一些说明" class="headerlink" title="Python类的一些说明"></a>Python类的一些说明</h1><p>[TOC]</p><a id="more"></a><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;将方法当成类的一种属性来使用，注意要显示声明类继承object：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFunction</span><span class="params">()</span>:</span></div><div class="line"><span class="keyword">print</span> <span class="string">'my function'</span></div></pre></td></tr></table></figure></p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;介绍yield前有必要先说明下Python中的迭代器(iterator)和生成器(constructor)。<br>&nbsp;<br>一、迭代器(iterator)<br>&nbsp;&nbsp;&nbsp;&nbsp;在Python中，for循环可以用于Python中的任何类型，包括列表、元祖等等，实际上，for循环可用于任何“可迭代对象”，这其实就是迭代器<br>&nbsp;&nbsp;&nbsp;&nbsp;迭代器是一个实现了迭代器协议的对象，Python中的迭代器协议就是有next方法的对象会前进到下一结果，而在一系列结果的末尾是，则会引发StopIteration。任何这类的对象在Python中都可以用for循环或其他遍历工具迭代，迭代工具内部会在每次迭代时调用next方法，并且捕捉StopIteration异常来确定何时离开。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用迭代器一个显而易见的<strong>好处</strong>就是：每次只从对象中读取一条数据，不会造成内存的过大开销。<br>&nbsp;&nbsp;&nbsp;&nbsp;比如要逐行读取一个文件的内容，利用readlines()方法，我们可以这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">"test.txt"</span>).readlines():</div><div class="line">    <span class="keyword">print</span> line</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这样虽然可以工作，但不是最好的方法。因为他实际上是把文件一次加载到内存中，然后逐行打印。当文件很大时，这个方法的内存开销就很大了。<br>&nbsp;&nbsp;&nbsp;&nbsp;利用file的迭代器，我们可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">"test.txt"</span>):   <span class="comment">#use file iterators</span></div><div class="line">    <span class="keyword">print</span> line</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这是最简单也是运行速度最快的写法，他并没显式的读取文件，而是利用迭代器每次读取下一行。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>二、生成器(constructor)<br>&nbsp;&nbsp;&nbsp;&nbsp;生成器函数在Python中与迭代器协议的概念联系在一起。简而言之，包含yield语句的函数会被特地编译成生成器。当函数被调用时，他们返回一个生成器对象，这个对象支持迭代器接口。函数也许会有个return语句，但它的作用是用来yield产生值的。<br>&nbsp;&nbsp;&nbsp;&nbsp;不像一般的函数会生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行和状态，他的本地变量将保存状态信息，这些信息在函数恢复时将再度有效<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(n)</span>:</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line"><span class="keyword">yield</span> i **<span class="number">2</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;调用时：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t = g(5)</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.next()</span></div><div class="line">0</div><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.next()</span></div><div class="line">1</div><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.next()</span></div><div class="line">4</div><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.next()</span></div><div class="line">9</div><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.next()</span></div><div class="line">16</div><div class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.next()</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</div><div class="line">StopIteration</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在运行完5次next之后，生成器抛出了一个StopIteration异常，迭代终止。</p><h2 id="range与xrange"><a href="#range与xrange" class="headerlink" title="range与xrange"></a>range与xrange</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):<span class="keyword">pass</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):<span class="keyword">pass</span></div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;range会生成一个1000个元素的list，占用内存大，而xrange在每次迭代中返回下一个数值，占用内存小</p><h2 id="str函数和repr函数"><a href="#str函数和repr函数" class="headerlink" title="str函数和repr函数"></a>str函数和repr函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;内建函数<code>str()</code>和<code>repr()</code> (representation，表达，表示)或反引号操作符(``)可以方便地以字符串的方式获取对象的内容、类型、数值属性等信息。<code>str()</code>函数得到的字符串可读性好（故被<code>print</code>调用），而<code>repr()</code>函数得到的字符串通常可以用来重新获得该对象，通常情况下 <code>obj==eval(repr(obj))</code> 这个等式是成立的。这两个函数接受一个对象作为其参数，返回适当的字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;事实上repr()和``做一样的事情，返回一个对象的“官方”字符串表示。其结果绝大多数情况下（不是所有）可以通过求值运算（内建函数<code>eval()</code>）重新得到该对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;str()则不同，它生成一个对象的可读性好的字符串表示，结果通常无法用eval()`求值，但适合print输出。</p><h2 id="is和id"><a href="#is和id" class="headerlink" title="is和id"></a>is和id</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;id函数可以获得对象的内存地址，如果两个对象的内存地址是一样的，那么这两个对象肯定是一个对象。和is是等价的。但是id和is本质上是两个不同的概念，详细：<a href="http://blog.jobbole.com/49705/" target="_blank" rel="external">参考链接</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python类的一些说明&quot;&gt;&lt;a href=&quot;#Python类的一些说明&quot; class=&quot;headerlink&quot; title=&quot;Python类的一些说明&quot;&gt;&lt;/a&gt;Python类的一些说明&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python-configparser库学习笔记</title>
    <link href="http://yoursite.com/2018/06/30/python-configparser%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/30/python-configparser库学习笔记/</id>
    <published>2018-06-30T06:01:14.000Z</published>
    <updated>2018-06-30T06:01:43.185Z</updated>
    
    <content type="html"><![CDATA[<p>我们在编写代码的过程中经常需要使用配置文件进行参数的动态配置，常见的配置文件有ini、cfg、xml等类型，他们的区别可以参考这个链接和这个链接，总的来说ini格式的文件最适合人类易读，xml格式的配置文件功能更强大，个人偏向于使用ini配置文件，编写简单容易理解，ConfigParser是Python下用于操作INI类型配置文件的库，下面对它的使用方法进行简单的说明。</p><a id="more"></a><p>一、快速上手指南</p><p>首先，安装库，很简单：</p><pre><code>pip install configparser</code></pre><p>一份常见的ini配置文件格式如下：</p><pre><code>[DEFAULT]ServerAliveInterval = 45Compression = yesCompressionLevel = 9ForwardX11 = yes[bitbucket.org]User = hg[topsecret.server.com]Port = 50022ForwardX11 = no</code></pre><p>我们定义：</p><ul><li>结点(sections)：配置文件中用中括号扩起来的部分，表示配置项所属的域；</li><li>键(key)：结点中具体配置项等号左边的值，表示配置项的名称；</li><li>值(value)：结点中具体配置项等号右边的值，表示配置项的值；</li></ul><p>下面我们用configparser来生成这个配置文件，注意观察代码中不同生成方式，代码如下：</p><pre><code>import configparserconfig = configparser.ConfigParser()# 通过key-value对的形式直接创建配置项config[&#39;DEFAULT&#39;] = {    &#39;ServerAliveInterval&#39;:&#39;45&#39;,    &#39;Compression&#39;:&#39;yes&#39;,    &#39;CompressionLevel&#39;:&#39;9&#39;,    &#39;ForwardX11&#39;:&#39;yes&#39;}# 通过类似数组的方式添加配置项config[&#39;bitbucket.org&#39;] = {}config[&#39;bitbucket.org&#39;][&#39;User&#39;] = &#39;hg&#39;# 将父结点赋给一个变量，然后通过变量添加配置项topsecret = config[&#39;topsecret.server.com&#39;]topsecret[&#39;Port&#39;] = &#39;50022&#39;     # mutates the parsertopsecret[&#39;ForwardX11&#39;] = &#39;no&#39;  # same here# 最后写入到文件中with open(&#39;example.ini&#39;, &#39;w&#39;) as configfile:   config.write(configfile)</code></pre><p>从上面的代码我们可以发现，configparser处理配置项的流程和Python中的字典类似(当然也有区别)，那么我们接下来用代码来读取这个配置文件：</p><pre><code>&gt;&gt;&gt; import configparser&gt;&gt;&gt; config = configparser.ConfigParser()&gt;&gt;&gt; config.sections()[]&gt;&gt;&gt; config.read(&#39;example.ini&#39;)[&#39;example.ini&#39;]&gt;&gt;&gt; config.sections()[&#39;bitbucket.org&#39;, &#39;topsecret.server.com&#39;]&gt;&gt;&gt; &#39;bitbucket.org&#39; in configTrue&gt;&gt;&gt; &#39;bytebong.com&#39; in configFalse&gt;&gt;&gt; config[&#39;bitbucket.org&#39;][&#39;User&#39;]&#39;hg&#39;&gt;&gt;&gt; config[&#39;DEFAULT&#39;][&#39;Compression&#39;]&#39;yes&#39;&gt;&gt;&gt; topsecret = config[&#39;topsecret.server.com&#39;]&gt;&gt;&gt; topsecret[&#39;ForwardX11&#39;]&#39;no&#39;&gt;&gt;&gt; topsecret[&#39;Port&#39;]&#39;50022&#39;&gt;&gt;&gt; for key in config[&#39;bitbucket.org&#39;]: print(key)...usercompressionlevelserveraliveintervalcompressionforwardx11&gt;&gt;&gt; config[&#39;bitbucket.org&#39;][&#39;ForwardX11&#39;]&#39;yes&#39;</code></pre><p>二、详细使用说明</p><p>2.1、参数类型转换</p><p>ConfigParser默认将配置文件中的配置项value作为str读取，所以如果你需要特定的数据类型，你需要手动进行转换，代码示例如下：</p><pre><code>&gt;&gt;&gt; int(topsecret[&#39;Port&#39;])50022&gt;&gt;&gt; float(topsecret[&#39;CompressionLevel&#39;])9.0</code></pre><p>当然，在日常操作中，我们显然会频繁的使用这些操作，对此，ConfigParser也内置了一些方法来直接转换数据类型：</p><pre><code>getint()           # 转换intgetfloat()      # 转换floatgetboolean()    # 转换为布尔类型</code></pre><p>示例代码如下：</p><pre><code>&gt;&gt;&gt; import configparser&gt;&gt;&gt; config = configparser.ConfigParser()&gt;&gt;&gt; topsecret = config[&#39;topsecret.server.com&#39;]&gt;&gt;&gt; topsecret.getboolean(&#39;ForwardX11&#39;)False&gt;&gt;&gt; config[&#39;bitbucket.org&#39;].getboolean(&#39;ForwardX11&#39;)True&gt;&gt;&gt; config.getboolean(&#39;bitbucket.org&#39;, &#39;Compression&#39;)True</code></pre><p>2.2、配置项的备选值(fallback values)与默认值(default value)</p><p>与字典对象类似，你可以使用get()方法来获取某个key对应的value，在ConfigParser中有两种特殊的value特性：</p><ul><li>备选值(fallback values)：当key对应的值不存在，或者key本身就不存在时，生成这个key并为之提供一个value；</li><li>默认值(default value)：当key定义在DEFAULT结点，而我们却在其他结点，假设为TMP结点中获取该值时，则使用DEFAULT中的值；</li><li>默认值的优先级始终高于备选值，如果定义了默认值，那么即使明确声明了备选值，最终获取到的还是默认值；</li></ul><p>示例如下：</p><pre><code>&gt;&gt;&gt; import configparser&gt;&gt;&gt; config = configparser.ConfigParser()&gt;&gt;&gt; topsecret = config[&#39;topsecret.server.com&#39;]&gt;&gt;&gt; topsecret.get(&#39;Port&#39;)    # 使用get获取某个key对应的值&#39;50022&#39;&gt;&gt;&gt; topsecret.get(&#39;Cipher&#39;)    # 获取某个不存在的key，此时没有返回值&gt;&gt;&gt; topsecret.get(&#39;Cipher&#39;, &#39;3des-cbc&#39;)    # 当定义了备选值之后，返回该备选值&#39;3des-cbc&#39;&gt;&gt;&gt; topsecret.get(&#39;CompressionLevel&#39;, &#39;3&#39;)    # 定义了默认值之后，备选值无效&#39;9&#39;</code></pre><p>2.3、INI文件特性</p><p>配置文件有一些特性：</p><ul><li>键值之间既可以用等号，也可以使用冒号；</li><li>结点是大小写敏感的，键值对则不敏感；</li><li>键值头尾的空格会自动过滤掉；</li><li>可以在行首使用#或;来添加注释，但注意，注释不可以缩进；</li><li>值可以跨行，但是要注意缩进；</li><li>值可以为空；</li></ul><p>如下是一份比较复杂的配置文件：</p><pre><code>[Simple Values]key=valuespaces in keys=allowedspaces in values=allowed as wellspaces around the delimiter = obviouslyyou can also use : to delimit keys from values[All Values Are Strings]values like this: 1000000or this: 3.14159265359are they treated as numbers? : nointegers, floats and booleans are held as: stringscan use the API to get converted values directly: true[Multiline Values]chorus: I&#39;m a lumberjack, and I&#39;m okay    I sleep all night and I work all day # 注意缩进[No Values]key_without_valueempty string value here =[You can use comments]# like this; or this# By default only in an empty line.# Inline comments can be harmful because they prevent users# from using the delimiting characters as parts of values.# That being said, this can be customized.    [Sections Can Be Indented]        can_values_be_as_well = True        does_that_mean_anything_special = False        purpose = formatting for readability        multiline_values = are            handled just fine as            long as they are indented            deeper than the first line            of a value        # Did I mention we can indent comments, too?</code></pre><p>2.4、动态插值(Interpolation)</p><p>ConfigParser支持值的动态插入(Interpolation)，意味着我们可以动态的赋值给参数，有两种动态插入模式：</p><ul><li>class configparser.BasicInterpolation：默认的插值模式；</li><li>class configparser.ExtendedInterpolation：扩展的插值模式，支持更复杂的语法；</li></ul><p>例如默认的插值模式下：</p><pre><code>[Paths]home_dir: /Usersmy_dir: %(home_dir)s/lumberjackmy_pictures: %(my_dir)s/Pictures</code></pre><p>这个例子中，%(home_dir)会被动态的替换为用户的主目录，%(my_dir)也类似，这样做的好处是灵活性，不必将某些字段写死在配置文件中，否则在其他用户的机器上写死的文件可能会影响使用。</p><p>而在扩展插值模式下，默认使用${section:option}语法来引用其他结点的值，例如上文中的例子在扩展插值模式下格式应该这样写:</p><pre><code>[Paths]home_dir: /Usersmy_dir: ${home_dir}/lumberjackmy_pictures: ${my_dir}/Pictures</code></pre><p>更常见的是下面这种格式：</p><pre><code>[Common]  # 这里定义被引用的值home_dir: /Userslibrary_dir: /Librarysystem_dir: /Systemmacports_dir: /opt/local[Frameworks]Python: 3.2path: ${Common:system_dir}/Library/Frameworks/ # 通过键值的方式引用值[Arthur]nickname: Two Shedslast_name: Jacksonmy_dir: ${Common:home_dir}/twoshedsmy_pictures: ${my_dir}/Picturespython_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}</code></pre><p>2.5、映射协议访问(Mapping Protocol Access)</p><p>映射协议访问(名称翻译不太确定)是泛指那些可以像字典对象一样操作用户对象的方法(Mapping protocol access is a generic name for functionality that enables using custom objects as if they were dictionaries)，在configparser中，映射接口(mapping interface)的实现是通过parser[‘section’][‘option’]语法来实现的。</p><p>14.2.6</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在编写代码的过程中经常需要使用配置文件进行参数的动态配置，常见的配置文件有ini、cfg、xml等类型，他们的区别可以参考这个链接和这个链接，总的来说ini格式的文件最适合人类易读，xml格式的配置文件功能更强大，个人偏向于使用ini配置文件，编写简单容易理解，ConfigParser是Python下用于操作INI类型配置文件的库，下面对它的使用方法进行简单的说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-Click库学习笔记</title>
    <link href="http://yoursite.com/2018/06/30/Python-Click%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/30/Python-Click库学习笔记/</id>
    <published>2018-06-30T05:59:48.000Z</published>
    <updated>2018-06-30T06:00:51.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Click"><a href="#Click" class="headerlink" title="Click"></a>Click</h1><p><a href="https://github.com/pallets/click" target="_blank" rel="external">Click</a> 是 <a href="https://github.com/pallets/flask" target="_blank" rel="external">Flask</a> 的开发团队 <a href="https://github.com/pallets" target="_blank" rel="external">Pallets</a> 的另一款开源项目，它是用于快速创建命令行的第三方模块。我们知道，Python 内置了一个 <a href="https://docs.python.org/2/howto/argparse.html" target="_blank" rel="external">Argparse</a> 的标准库用于创建命令行，但使用起来有些繁琐，<a href="https://github.com/pallets/click" target="_blank" rel="external">Click</a> 相比于 <a href="https://docs.python.org/2/howto/argparse.html" target="_blank" rel="external">Argparse</a>，就好比 <a href="https://github.com/kennethreitz/requests" target="_blank" rel="external">requests</a> 相比于 <a href="https://docs.python.org/2/library/urllib.html" target="_blank" rel="external">urllib</a>。</p><a id="more"></a><p>Click 的使用大致有两个步骤：</p><ol><li>使用 <code>@click.command()</code> 装饰一个函数，使之成为命令行接口；</li><li>使用 <code>@click.option()</code> 等装饰函数，为其添加命令行选项等。</li></ol><p>下面，让我们看一下<a href="http://click.pocoo.org/6/" target="_blank" rel="external">官方文档</a>的入门例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--count', default=1, help='Number of greetings.')</span></div><div class="line"><span class="meta">@click.option('--name', prompt='Your name', help='The person to greet.')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(count, name)</span>:</span></div><div class="line">    <span class="string">"""Simple program that greets NAME for a total of COUNT times."""</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(count):</div><div class="line">        click.echo(<span class="string">'Hello %s!'</span> % name)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    hello()</div></pre></td></tr></table></figure><p>在上面的例子中，函数 <code>hello</code> 有两个参数：count 和 name，它们的值从命令行中获取。</p><ul><li><code>@click.command()</code> 使函数 <code>hello</code> 成为命令行接口；</li><li><code>@click.option</code> 的第一个参数指定了命令行选项的名称，不难猜到，count 的默认值是 1，name 的值从输入获取；</li><li>使用 <code>click.echo</code> 进行输出是为了获得更好的兼容性，因为 <code>print</code> 在 Python2 和 Python3 的用法有些差别。</li></ul><p>看看执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ python hello.py</div><div class="line">Your name: Ethan           <span class="comment"># 这里会显示 'Your name: '(对应代码中的 prompt)，接受用户输入</span></div><div class="line">Hello Ethan!</div><div class="line"></div><div class="line">$ python hello.py --<span class="built_in">help</span>   <span class="comment"># click 帮我们自动生成了 `--help` 用法</span></div><div class="line">Usage: hello.py [OPTIONS]</div><div class="line"></div><div class="line">  Simple program that greets NAME <span class="keyword">for</span> a total of COUNT <span class="built_in">times</span>.</div><div class="line"></div><div class="line">Options:</div><div class="line">  --count INTEGER  Number of greetings.</div><div class="line">  --name TEXT      The person to greet.</div><div class="line">  --<span class="built_in">help</span>           Show this message and <span class="built_in">exit</span>.</div><div class="line"></div><div class="line">$ python hello.py --count 3 --name Ethan    <span class="comment"># 指定 count 和 name 的值</span></div><div class="line">Hello Ethan!</div><div class="line">Hello Ethan!</div><div class="line">Hello Ethan!</div><div class="line"></div><div class="line">$ python hello.py --count=3 --name=Ethan    <span class="comment"># 也可以使用 `=`，和上面等价</span></div><div class="line">Hello Ethan!</div><div class="line">Hello Ethan!</div><div class="line">Hello Ethan!</div><div class="line"></div><div class="line">$ python hello.py --name=Ethan              <span class="comment"># 没有指定 count，默认值是 1</span></div><div class="line">Hello Ethan!</div></pre></td></tr></table></figure><h1 id="click-option"><a href="#click-option" class="headerlink" title="click.option"></a>click.option</h1><p>option 最基本的用法就是通过指定命令行选项的名称，从命令行读取参数值，再将其传递给函数。在上面的例子，我们看到，除了设置命令行选项的名称，我们还会指定默认值，help 说明等，option 常用的设置参数如下：</p><ul><li>default: 设置命令行参数的默认值</li><li>help: 参数说明</li><li>type: 参数类型，可以是 string, int, float 等</li><li>prompt: 当在命令行中没有输入相应的参数时，会根据 prompt 提示用户输入</li><li>nargs: 指定命令行参数接收的值的个数</li></ul><p>下面，我们再看看相关的例子。</p><h2 id="指定-type"><a href="#指定-type" class="headerlink" title="指定 type"></a>指定 type</h2><p>我们可以使用 <code>type</code> 来指定参数类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--rate', type=float, help='rate')   # 指定rate是float类型</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(rate)</span>:</span></div><div class="line">    click.echo(<span class="string">'rate: %s'</span> % rate)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    show()</div></pre></td></tr></table></figure><p>执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ python click_type.py --rate 1</div><div class="line">rate: 1.0</div><div class="line">$ python click_type.py --rate 0.66</div><div class="line">rate: 0.66</div></pre></td></tr></table></figure><h2 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h2><p>在某些情况下，一个参数的值只能是某些可选的值，如果用户输入了其他值，我们应该提示用户输入正确的值。在这种情况下，我们可以通过 <code>click.Choice()</code> 来限定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--gender', type=click.Choice(['man', 'woman']))    # 限定值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span><span class="params">(gender)</span>:</span></div><div class="line">    click.echo(<span class="string">'gender: %s'</span> % gender)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    choose()</div></pre></td></tr></table></figure><p>执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python click_choice.py --gender boy</div><div class="line">Usage: click_choice.py [OPTIONS]</div><div class="line"></div><div class="line">Error: Invalid value <span class="keyword">for</span> <span class="string">"--gender"</span>: invalid choice: boy. (choose from man, woman)</div><div class="line"></div><div class="line">$ python click_choice.py --gender man</div><div class="line">gender: man</div></pre></td></tr></table></figure><h2 id="多值参数"><a href="#多值参数" class="headerlink" title="多值参数"></a>多值参数</h2><p>有时，一个参数需要接收多个值。<strong>option 支持设置固定长度的参数值</strong>，通过 <code>nargs</code> 指定。</p><p>看看例子就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--center', nargs=2, type=float, help='center of the circle')</span></div><div class="line"><span class="meta">@click.option('--radius', type=float, help='radius of the circle')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle</span><span class="params">(center, radius)</span>:</span></div><div class="line">    click.echo(<span class="string">'center: %s, radius: %s'</span> % (center, radius))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    circle()</div></pre></td></tr></table></figure><p>在上面的例子中，option 指定了两个参数：center 和 radius，其中，center 表示二维平面上一个圆的圆心坐标，接收两个值，以元组的形式将值传递给函数，而 radius 表示圆的半径。</p><p>执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python click_multi_values.py --center 3 4 --radius 10</div><div class="line">center: (3.0, 4.0), radius: 10.0</div><div class="line"></div><div class="line">$ python click_multi_values.py --center 3 4 5 --radius 10</div><div class="line">Usage: click_multi_values.py [OPTIONS]</div><div class="line"></div><div class="line">Error: Got unexpected extra argument (5)</div></pre></td></tr></table></figure><h2 id="输入密码"><a href="#输入密码" class="headerlink" title="输入密码"></a>输入密码</h2><p>有时，在输入密码的时候，我们希望能隐藏显示。option 提供了两个参数来设置密码的输入：hide_input 和 confirmation_promt，其中，hide_input 用于隐藏输入，confirmation_promt 用于重复输入。</p><p>看看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--password', prompt=True, hide_input=True, confirmation_prompt=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_password</span><span class="params">(password)</span>:</span></div><div class="line">    click.echo(<span class="string">'password: %s'</span> % password)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    input_password()</div></pre></td></tr></table></figure><p>执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ python click_password.py</div><div class="line">Password:                         <span class="comment"># 不会显示密码</span></div><div class="line">Repeat <span class="keyword">for</span> confirmation:          <span class="comment"># 重复一遍</span></div><div class="line">password: 666666</div></pre></td></tr></table></figure><p>由于上面的写法有点繁琐，click 也提供了一种快捷的方式，通过使用 <code>@click.password_option()</code>，上面的代码可以简写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.password_option()</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_password</span><span class="params">(password)</span>:</span></div><div class="line">    click.echo(<span class="string">'password: %s'</span> % password)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    input_password()</div></pre></td></tr></table></figure><h2 id="改变命令行程序的执行"><a href="#改变命令行程序的执行" class="headerlink" title="改变命令行程序的执行"></a>改变命令行程序的执行</h2><p>有些参数会改变命令行程序的执行，比如在终端输入 <code>python</code> 是进入 python 控制台，而输入 <code>python --version</code> 是打印 python 版本。Click 提供 eager 标识对参数名进行标识，如果输入该参数，则会拦截既定的命令行执行流程，跳转去执行一个回调函数。</p><p>让我们看看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_version</span><span class="params">(ctx, param, value)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> value <span class="keyword">or</span> ctx.resilient_parsing:</div><div class="line">        <span class="keyword">return</span></div><div class="line">    click.echo(<span class="string">'Version 1.0'</span>)</div><div class="line">    ctx.exit()</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--version', is_flag=True, callback=print_version,</span></div><div class="line">              expose_value=<span class="keyword">False</span>, is_eager=<span class="keyword">True</span>)</div><div class="line"><span class="meta">@click.option('--name', default='Ethan', help='name')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    click.echo(<span class="string">'Hello %s!'</span> % name)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    hello()</div></pre></td></tr></table></figure><p>其中：</p><ul><li><code>is_eager=True</code> 表明该命令行选项优先级高于其他选项；</li><li><code>expose_value=False</code> 表示如果没有输入该命令行选项，会执行既定的命令行流程；</li><li><code>callback</code> 指定了输入该命令行选项时，要跳转执行的函数；</li></ul><p>执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ python click_eager.py</div><div class="line">Hello Ethan!</div><div class="line"></div><div class="line">$ python click_eager.py --version                   <span class="comment"># 拦截既定的命令行执行流程</span></div><div class="line">Version 1.0</div><div class="line"></div><div class="line">$ python click_eager.py --name Michael</div><div class="line">Hello Michael!</div><div class="line"></div><div class="line">$ python click_eager.py --version --name Ethan      <span class="comment"># 忽略 name 选项</span></div><div class="line">Version 1.0</div></pre></td></tr></table></figure><h1 id="click-argument"><a href="#click-argument" class="headerlink" title="click.argument"></a>click.argument</h1><p>我们除了使用 <code>@click.option</code> 来添加<strong>可选参数</strong>，还会经常使用 <code>@click.argument</code> 来添加<strong>固定参数</strong>。它的使用和 option 类似，但支持的功能比 option 少。</p><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.argument('coordinates')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(coordinates)</span>:</span></div><div class="line">    click.echo(<span class="string">'coordinates: %s'</span> % coordinates)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    show()</div></pre></td></tr></table></figure><p>看看执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ python click_argument.py                     <span class="comment"># 错误，缺少参数 coordinates</span></div><div class="line">Usage: click_argument.py [OPTIONS] COORDINATES</div><div class="line"></div><div class="line">Error: Missing argument <span class="string">"coordinates"</span>.</div><div class="line"></div><div class="line">$ python click_argument.py --<span class="built_in">help</span>              <span class="comment"># argument 指定的参数在 help 中没有显示</span></div><div class="line">Usage: click_argument.py [OPTIONS] COORDINATES</div><div class="line"></div><div class="line">Options:</div><div class="line">  --<span class="built_in">help</span>  Show this message and <span class="built_in">exit</span>.</div><div class="line"></div><div class="line">$ python click_argument.py --coordinates 10    <span class="comment"># 错误用法，这是 option 参数的用法</span></div><div class="line">Error: no such option: --coordinates</div><div class="line"></div><div class="line">$ python click_argument.py 10                  <span class="comment"># 正确，直接输入值即可</span></div><div class="line">coordinates: 10</div></pre></td></tr></table></figure><h2 id="多个-argument"><a href="#多个-argument" class="headerlink" title="多个 argument"></a>多个 argument</h2><p>我们再来看看多个 argument 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.argument('x')</span></div><div class="line"><span class="meta">@click.argument('y')</span></div><div class="line"><span class="meta">@click.argument('z')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(x, y, z)</span>:</span></div><div class="line">    click.echo(<span class="string">'x: %s, y: %s, z:%s'</span> % (x, y, z))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    show()</div></pre></td></tr></table></figure><p>执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ python click_argument.py 10 20 30</div><div class="line">x: 10, y: 20, z:30</div><div class="line"></div><div class="line">$ python click_argument.py 10</div><div class="line">Usage: click_argument.py [OPTIONS] X Y Z</div><div class="line"></div><div class="line">Error: Missing argument <span class="string">"y"</span>.</div><div class="line"></div><div class="line">$ python click_argument.py 10 20</div><div class="line">Usage: click_argument.py [OPTIONS] X Y Z</div><div class="line"></div><div class="line">Error: Missing argument <span class="string">"z"</span>.</div><div class="line"></div><div class="line">$ python click_argument.py 10 20 30 40</div><div class="line">Usage: click_argument.py [OPTIONS] X Y Z</div><div class="line"></div><div class="line">Error: Got unexpected extra argument (40)</div></pre></td></tr></table></figure><h2 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h2><p>argument 还有另外一种常见的用法，就是接收不定量的参数，让我们看看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.argument('src', nargs=-1)</span></div><div class="line"><span class="meta">@click.argument('dst', nargs=1)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(src, dst)</span>:</span></div><div class="line">    click.echo(<span class="string">'move %s to %s'</span> % (src, dst))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    move()</div></pre></td></tr></table></figure><p>其中，<code>nargs=-1</code> 表明参数 <code>src</code> 接收不定量的参数值，参数值会以 tuple 的形式传入函数。如果 <code>nargs</code> 大于等于 1，表示接收 <code>nargs</code> 个参数值，上面的例子中，<code>dst</code> 接收一个参数值。</p><p>让我们看看执行情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ python click_argument.py file1 trash    <span class="comment"># src=('file1',)  dst='trash'</span></div><div class="line">move (u<span class="string">'file1'</span>,) to trash</div><div class="line"></div><div class="line">$ python click_argument.py file1 file2 file3 trash   <span class="comment"># src=('file1', 'file2', 'file3')  dst='trash'</span></div><div class="line">move (u<span class="string">'file1'</span>, u<span class="string">'file2'</span>, u<span class="string">'file3'</span>) to trash</div></pre></td></tr></table></figure><h1 id="彩色输出"><a href="#彩色输出" class="headerlink" title="彩色输出"></a>彩色输出</h1><p>在前面的例子中，我们使用 <code>click.echo</code> 进行输出，如果配合 <a href="https://pypi.python.org/pypi/colorama" target="_blank" rel="external">colorama</a> 这个模块，我们可以使用 <code>click.secho</code> 进行彩色输出，在使用之前，使用 pip 安装 colorama：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install colorama</div></pre></td></tr></table></figure><p>看看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('--name', help='The person to greet.')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    click.secho(<span class="string">'Hello %s!'</span> % name, fg=<span class="string">'red'</span>, underline=<span class="keyword">True</span>)</div><div class="line">    click.secho(<span class="string">'Hello %s!'</span> % name, fg=<span class="string">'yellow'</span>, bg=<span class="string">'black'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    hello()</div></pre></td></tr></table></figure><p>其中:</p><ul><li><code>fg</code> 表示前景颜色（即字体颜色），可选值有：BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE 等；</li><li><code>bg</code> 表示背景颜色，可选值有：BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE 等；</li><li><code>underline</code> 表示下划线，可选的样式还有：<code>dim=True</code>，<code>bold=True</code> 等；</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>使用 <code>click.command()</code> 装饰一个函数，使其成为命令行接口。</li><li>使用 <code>click.option()</code> 添加可选参数，支持设置固定长度的参数值。</li><li>使用 <code>click.argument()</code> 添加固定参数，支持设置不定长度的参数值。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://click.pocoo.org/6/" target="_blank" rel="external">Click Documentation (6.0)</a></li><li><a href="https://isudox.com/2016/09/03/learning-python-package-click/" target="_blank" rel="external">Python Click 学习笔记 | I sudo X</a></li><li><a href="http://cdwanze.github.io/%E7%94%B5%E8%84%91/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/click%E6%A8%A1%E5%9D%97.html" target="_blank" rel="external">click模块 - cdwanze</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Click&quot;&gt;&lt;a href=&quot;#Click&quot; class=&quot;headerlink&quot; title=&quot;Click&quot;&gt;&lt;/a&gt;Click&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/pallets/click&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Click&lt;/a&gt; 是 &lt;a href=&quot;https://github.com/pallets/flask&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flask&lt;/a&gt; 的开发团队 &lt;a href=&quot;https://github.com/pallets&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pallets&lt;/a&gt; 的另一款开源项目，它是用于快速创建命令行的第三方模块。我们知道，Python 内置了一个 &lt;a href=&quot;https://docs.python.org/2/howto/argparse.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Argparse&lt;/a&gt; 的标准库用于创建命令行，但使用起来有些繁琐，&lt;a href=&quot;https://github.com/pallets/click&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Click&lt;/a&gt; 相比于 &lt;a href=&quot;https://docs.python.org/2/howto/argparse.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Argparse&lt;/a&gt;，就好比 &lt;a href=&quot;https://github.com/kennethreitz/requests&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;requests&lt;/a&gt; 相比于 &lt;a href=&quot;https://docs.python.org/2/library/urllib.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;urllib&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost安装手册</title>
    <link href="http://yoursite.com/2018/06/06/Anaconda%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/06/06/Anaconda安装、配置/</id>
    <published>2018-06-06T12:21:20.981Z</published>
    <updated>2018-06-06T12:21:20.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h1><h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p>在<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">这里</a>下载最新版本Anaconda，下载完成后，用<code>root</code>用户在控制台执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh Anaconda3-5.0.1-Linux-x86_64.sh</div></pre></td></tr></table></figure><p>添加清华源，加快插件下载速度，详情参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="external">这里</a>。<br><a id="more"></a></p><p>添加<code>XGBoost</code>，添加方法参考<a href="https://anaconda.org/akode/xgboost" target="_blank" rel="external">这里</a>或者如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># step1、(如果安装过程出错提示“无法找到g++”时)安装g++</span></div><div class="line">sudo apt-get install g++</div><div class="line"></div><div class="line"><span class="comment"># step2、pip安装</span></div><div class="line">pip install -y xgboost</div></pre></td></tr></table></figure><p><code>Anaconda</code>自带的<code>Jupyter Notebook</code>可以安装插件使之更好用，如代码折叠、黑色主题等，安装及配置方法可以参考<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="external">这里</a>，ps.这个库如果安装过程中出现和http异常的情况时，多试几次就可以。</p><p>参考<a href="http://www.itwendao.com/article/detail/460543.html" target="_blank" rel="external">这里</a>使用<code>MNIST</code>搭建demo</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XGBoost&quot;&gt;&lt;a href=&quot;#XGBoost&quot; class=&quot;headerlink&quot; title=&quot;XGBoost&quot;&gt;&lt;/a&gt;XGBoost&lt;/h1&gt;&lt;h2 id=&quot;一、下载&quot;&gt;&lt;a href=&quot;#一、下载&quot; class=&quot;headerlink&quot; title=&quot;一、下载&quot;&gt;&lt;/a&gt;一、下载&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;下载最新版本Anaconda，下载完成后，用&lt;code&gt;root&lt;/code&gt;用户在控制台执行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sh Anaconda3-5.0.1-Linux-x86_64.sh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;添加清华源，加快插件下载速度，详情参考&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="XGBoost" scheme="http://yoursite.com/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>superset-开源的BI及数据可视化工具开坑记</title>
    <link href="http://yoursite.com/2018/06/02/superset-%E5%BC%80%E6%BA%90%E7%9A%84BI%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E5%BC%80%E5%9D%91%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/02/superset-开源的BI及数据可视化工具开坑记/</id>
    <published>2018-06-02T04:38:47.000Z</published>
    <updated>2018-06-30T07:06:28.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>先引用一个官网的介绍：</p><blockquote><p><code>Superset</code>曾用名Caravel, Panoramix, 是由Airbnb（知名在线房屋短租公司）开源的数据分析与可视化平台, 该工具主要特点是可自助分析, 自定义仪表盘, 分析结果可视化（导出）, 用户/角色权限控制, 还集成了一个SQL编辑器, 可以进行SQL编辑查询等。</p></blockquote><p><code>Superset</code>的后端完全基于<code>Python</code>，使用到了<code>Flask</code>、<code>Pandas</code>、<code>SqlAlchemy</code>等库，前端则使用了<code>react</code>、<code>webpack</code>，保证了界面显示流畅顺滑。</p><a id="more"></a> <p><img src="https://raw.githubusercontent.com/apache/incubator-superset/master/superset/assets/images/screenshots/bank_dash.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/apache/incubator-superset/master/superset/assets/images/screenshots/explore.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/apache/incubator-superset/master/superset/assets/images/screenshots/sqllab.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/apache/incubator-superset/master/superset/assets/images/screenshots/visualizations.png" alt="img"></p><p>功能特性上直接翻译<a href="https://github.com/apache/incubator-superset" target="_blank" rel="external">官网</a>内容：</p><ul><li>交互式的数据分析及可视化工具，可以创建带交互的展示大屏；</li><li>提供大量的可视化图表；</li><li>提供对数据的下钻(drill down)、切分(slice)、切块(dice)；</li><li>提供sql查询界面，查询的结果可以直接进行可视化展示；</li><li>提供权限机制，保证数据可以根据权限隔离；</li><li>提供一个轻量的语义层( lightweight semantic layer)，用于控制数据展现的维度和度量；</li><li>对大多数sql类型数据库支持开箱即用；</li><li>支持Druid数据库；</li><li>支持缓存以更快的渲染图表。</li></ul><p>目前支持的数据库有：</p><ul><li>MySQL</li><li>Postgres</li><li>Vertica</li><li>Oracle</li><li>Microsoft SQL Server</li><li>SQLite</li><li>Greenplum</li><li>Firebird</li><li>MariaDB</li><li>Sybase</li><li>IBM DB2</li><li>Exasol</li><li>MonetDB</li><li>Snowflake</li><li>Redshift</li><li>Druid</li></ul><p>大致看了一下，图表应该是基于<code>D3.js</code>的，样式有点冷淡风格，先折腾着学习学习。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>官方的<a href="https://superset.incubator.apache.org/installation.html" target="_blank" rel="external">安装文档</a>提供了docker方式部署和直接部署两种方式，这边我选择直接部署。</p><p>官方安装文档中说明支持<code>Python 2.7</code>和<code>Python 3.4</code>，安装时注意版本。</p><p><code>Superset</code>将数据库链接信息存储在它的元数据库上，使用<code>cryptography</code>加密链接密码，这个库是依赖于底层操作系统的，我的开发环境是基于<code>Ubuntu</code>的<code>Deepin</code>，执行如下命令安装库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential libssl-dev libffi-dev python-dev python-pip libsasl2-dev libldap2-dev</div></pre></td></tr></table></figure><p>对OSX系统，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install pkg-config libffi openssl python</div><div class="line">env LDFLAGS=<span class="string">"-L<span class="variable">$(brew --prefix openssl)</span>/lib"</span> CFLAGS=<span class="string">"-I<span class="variable">$(brew --prefix openssl)</span>/include"</span> pip install cryptography==1.9</div></pre></td></tr></table></figure><p>对Windows系统，没有正式的官方支持，文档中介绍了使用pip安装的方法，不过个人建议开发还是不要用windows了，如果有win软件的依赖，可以试一下我现在使用的<code>deepin</code>深度linux系统，内置了<code>crossover</code>，不是特别复杂的exe软件都可以正常运行。</p><p>官方文档建议我们为<code>superset</code>创建一个虚拟的运行环境，文档中使用的是<code>virtualenv</code>，这边我们使用更先进的<code>pipenv</code>（可见我博客中“新一代Python虚拟环境库Pipenv学习笔记”）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir supersetMy  <span class="comment"># 创建文件夹</span></div><div class="line"><span class="built_in">cd</span> supersetMy  <span class="comment"># 进入文件夹</span></div><div class="line">pipenv shell  <span class="comment"># 使用pipenv创建虚拟环境并激活</span></div><div class="line">pipenv install superset<span class="comment"># 安装superset</span></div></pre></td></tr></table></figure><p>安装完成后我们首先要进行初始化，创建超级用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建管理员用户</span></div><div class="line">fabmanager create-admin --app superset</div><div class="line"><span class="comment"># 初始化数据库</span></div><div class="line">superset db upgrade</div><div class="line"><span class="comment"># 载入测试数据</span></div><div class="line">superset load_examples</div><div class="line"><span class="comment"># 创建默认角色与权限</span></div><div class="line">superset init</div><div class="line"><span class="comment"># 在本地8088端口创建服务，可以使用-p命令绑定其他端口</span></div><div class="line">superset runserver -d</div></pre></td></tr></table></figure><p>初始化完成后，在浏览器打开<code>http://localhost:8088</code>，使用创建的管理员账号(henan@123.com/henan)登录，就是这么简单！</p><p><img src="./superset-开源的BI及数据可视化工具开坑记/20180603091112.png" alt="20180603091112"></p><p>正常使用按照上文配置即可，<a href="https://superset.incubator.apache.org/installation.html" target="_blank" rel="external">官方文档</a>还提供了一些具体的配置，如服务器配置、负载均衡配置、数据库参数配置、缓存配置等，在部署到生产环境时，可以参照文档细心配置一下提升用户使用手感，这里暂时跳过。</p><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="3-1、创建数据库并探索数据"><a href="#3-1、创建数据库并探索数据" class="headerlink" title="3.1、创建数据库并探索数据"></a>3.1、创建数据库并探索数据</h3><p>登录后先单机右上角的小国旗，将语言改为中文，菜单栏会变成中文，方便使用。</p><p>这部分的笔记参考了<a href="https://superset.incubator.apache.org/tutorial.html" target="_blank" rel="external">官方文档</a>教程并稍作修改，若有说的不清楚的地方可以翻阅文档查看详细内容。</p><p>官方文档中创建了同mysql数据库的链接，我这里则通过导入csv文件的方式创建数据库，刚开始，csv文件是从windows机器下导出的，编码为ISO-8859，导入时会报utf8编码异常，于是想到要对编码进行转换，参考了<a href="https://linux.cn/article-7959-1.html" target="_blank" rel="external">这篇文章</a>中的方法，将csv转换为utf8：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看文件编码</span></div><div class="line">file -i train_data.csv</div><div class="line"></div><div class="line"><span class="comment"># 改变编码并保存</span></div><div class="line">iconv -f ISO-8859-1 -t UTF-8 train_data.csv -o train_data_utf8.csv</div></pre></td></tr></table></figure><p>转换后又报了<code>&#39;NoneType&#39; object is not subscriptable</code>这个异常，排查了许久没有发现问题在哪，于是摘取了一小块数据(2MB)重新新建csv然后执行导入，结果确是网页直接崩溃了，报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">网址为 http://localhost:8088/csvtodatabaseview/form 的网页可能暂时无法连接，或者它已永久性地移动到了新网址。</div><div class="line">ERR_RESPONSE_HEADERS_TOO_BIG</div></pre></td></tr></table></figure><p>WTF？查看<code>superset</code>的日志，提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UserWarning: The <span class="string">"b'session'"</span> cookie is too large: the value was 640742 bytes but the header required 26 extra bytes. The final size was 640768 bytes but the <span class="built_in">limit</span> is 4093 bytes. Browsers may silently ignore cookies larger than this.</div><div class="line">  samesite=samesite</div></pre></td></tr></table></figure><p>cookies太大了？搜索了一番，然后我尝试前人的解决思路：既然cookie太大，那么我就不限制cookie的大小，修改配置文件即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先进入python，找到库文件所在的路径</span></div><div class="line">python</div><div class="line">import sys</div><div class="line"><span class="built_in">print</span>(sys.path)</div><div class="line"></div><div class="line"><span class="comment"># 进入site-packages库所在路径</span></div><div class="line"><span class="built_in">cd</span> path/to/site-packages</div><div class="line"></div><div class="line"><span class="comment"># 修改werkzeug库下wrappers.py中max_cookie_size=0</span></div></pre></td></tr></table></figure><p>测试一下，恩，果然没有效果，依然崩溃，无解之下，在<a href="https://github.com/apache/incubator-superset/issues/5072" target="_blank" rel="external">GitHub Issue</a>上有人问到过类似的问题，跟帖回复了我的问题，等待官方的解答。</p><p>到这里我还是有点不死心，我的记录已经剪到了10000条，会不会是数据量太大的问题？于是我将数据再剪，剪到2000条，上传，成功了！然后在数据库里面看到了我之前所有尝试新建的表格：</p><p><img src="/home/henan/hexoMy/henan715.github.io/source/_posts/superset-开源的BI及数据可视化工具开坑记/20180603110622.png" alt="20180603110622"></p><p>WTF？？然而表格只有表结构没有数据，给跪！目前我提的问题还没有解决，所以说直接上传csv是不可行的了吗？TBC……</p><h3 id="3-2、使用图表探查数据"><a href="#3-2、使用图表探查数据" class="headerlink" title="3.2、使用图表探查数据"></a>3.2、使用图表探查数据</h3><p>导入自己的csv不可行，那么就用内置的测试数据继续后面的学习吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.jianshu.com/p/a6fe79d0b1b3" target="_blank" rel="external">Superset搭建及简单使用</a></li><li><a href="https://blog.csdn.net/qq273681448/article/details/75050513" target="_blank" rel="external">巧用Superset大数据分析平台搞定各种图表</a></li><li><a href="https://github.com/apache/incubator-superset/issues" target="_blank" rel="external">Github Issues</a></li><li>​</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;先引用一个官网的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Superset&lt;/code&gt;曾用名Caravel, Panoramix, 是由Airbnb（知名在线房屋短租公司）开源的数据分析与可视化平台, 该工具主要特点是可自助分析, 自定义仪表盘, 分析结果可视化（导出）, 用户/角色权限控制, 还集成了一个SQL编辑器, 可以进行SQL编辑查询等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Superset&lt;/code&gt;的后端完全基于&lt;code&gt;Python&lt;/code&gt;，使用到了&lt;code&gt;Flask&lt;/code&gt;、&lt;code&gt;Pandas&lt;/code&gt;、&lt;code&gt;SqlAlchemy&lt;/code&gt;等库，前端则使用了&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;webpack&lt;/code&gt;，保证了界面显示流畅顺滑。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新一代Python虚拟环境库Pipenv学习笔记</title>
    <link href="http://yoursite.com/2018/06/02/%E6%96%B0%E4%B8%80%E4%BB%A3Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%BA%93Pipenv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/02/新一代Python虚拟环境库Pipenv学习笔记/</id>
    <published>2018-06-02T03:47:29.000Z</published>
    <updated>2018-06-02T04:34:29.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>pipenv</code>是<code>requests</code>作者的一个项目, 整合了<code>virtualenv</code>, <code>pip</code>, <code>pipfile</code>, 用于更方便地为项目建立虚拟环境并管理虚拟环境中的第三方模块。</p><p>为什么用<code>pipenv</code>取代<code>virtualenv</code>呢，参照<a href="https://zhuanlan.zhihu.com/p/32913361" target="_blank" rel="external">这篇文章</a>提出了<code>virtualenv</code>的几个缺点：</p><ol><li>必须手动安装或删除某些特定版本的包，并记得定期更新requirements.txt文件，以保持项目环境的一致</li><li>有时项目中需要有多个requirements.txt文件，比如开发时应该用dev-requirements.txt，现有的模式不能满足这些复杂的需要</li><li>卸载包的时候只是卸载包自己，不能处理相关依赖，时间久了项目环境就混乱了</li></ol><a id="more"></a><p>而<code>pipenv</code>在前辈的基础上进行了优化，参照<a href="https://docs.pipenv.org/" target="_blank" rel="external">官网</a>，更新了如下特性：</p><ol><li>根据 Pipfile 自动寻找项目根目录。</li><li>如果不存在，可以自动生成 Pipfile 和 Pipfile.lock。</li><li>自动在项目目录的 .venv 目录创建虚拟环境。（当然这个目录地址通过设置WORKON_HOME改变）</li><li>自动管理 Pipfile 新安装和删除的包。</li><li>自动更新 pip。</li></ol><p>最大的区别在于：</p><ul><li><code>virtualenv</code>使用requirements.txt这种纯文本管理库，而<code>pipenv</code>使用<code>TOML</code>格式的pipfile文件进行管理，你可以根据实际需要建立开发环境和正式环境的pipfile，并且支持版本锁定，更智能、更自动、更高效；</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>linux下使用pip安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pipenv</div></pre></td></tr></table></figure><p>MAC下使用brew安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install pipenv</div></pre></td></tr></table></figure><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="3-1、创建并打开虚拟环境"><a href="#3-1、创建并打开虚拟环境" class="headerlink" title="3.1、创建并打开虚拟环境"></a>3.1、创建并打开虚拟环境</h3><p>最基础的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># step1、创建目录，并进入目录</span></div><div class="line">mkdir test_env</div><div class="line"><span class="built_in">cd</span> test_env</div><div class="line"></div><div class="line"><span class="comment"># step2、建立虚拟环境</span></div><div class="line">pipenv --two  <span class="comment"># 默认使用python2建立虚拟环境，使用--three则使用python3</span></div><div class="line"></div><div class="line"><span class="comment"># step3、激活虚拟环境</span></div><div class="line">pipenv shell</div><div class="line"></div><div class="line"><span class="comment"># step4、安装其他库</span></div><div class="line">pip install numpy pandas</div><div class="line"></div><div class="line"><span class="comment"># step5、退出虚拟环境</span></div><div class="line"><span class="built_in">exit</span></div></pre></td></tr></table></figure><p><img src="/home/henan/hexoMy/henan715.github.io/source/_posts/新一代Python虚拟环境库Pipenv学习笔记/01.gif" alt="01"></p><h3 id="3-2、进阶命令"><a href="#3-2、进阶命令" class="headerlink" title="3.2、进阶命令"></a>3.2、进阶命令</h3><p>创建指定版本的python虚拟环境(pipenv会自动扫描系统中是否有符合的版本)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pipenv --python 3</div><div class="line">pipenv --python 3.6</div><div class="line">pipenv --python 2.7.14</div></pre></td></tr></table></figure><p>从旧的<code>requirements.txt</code>安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv install -r path/to/requirements.txt</div></pre></td></tr></table></figure><p>安装指定版本的库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv install requests==2.13.0</div></pre></td></tr></table></figure></p><p>卸载指定的库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pipenv uninstall package_name</div><div class="line">pipenv uninstall --all <span class="comment"># 移除所有库</span></div><div class="line">pipenv uninstall --all-dev <span class="comment"># 移除测试环境所有的库</span></div></pre></td></tr></table></figure></p><p>创建lock文件，lock文件声明了所有的依赖以及子依赖信息，通常随着发布包一起发布：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv lock</div></pre></td></tr></table></figure></p><p>查看库依赖关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipenv graph</div></pre></td></tr></table></figure><h3 id="3-3、高级用法"><a href="#3-3、高级用法" class="headerlink" title="3.3、高级用法"></a>3.3、高级用法</h3><p>pipfile是pipenv自动生成的关于环境、库依赖等信息的文件，大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">source</span>]]</div><div class="line">url = <span class="string">"https://pypi.python.org/simple"</span></div><div class="line">verify_ssl = <span class="literal">true</span></div><div class="line">name = <span class="string">"pypi"</span></div><div class="line"></div><div class="line">[packages]</div><div class="line">numpy = <span class="string">"*"</span></div><div class="line">pandas = <span class="string">"*"</span></div><div class="line"></div><div class="line">[dev-packages]</div></pre></td></tr></table></figure><p>将pipfile转化为requirements.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pipenv lock -r</div><div class="line">pipenv locl -r --dev <span class="comment"># 输出测试环境的pipfile依赖</span></div></pre></td></tr></table></figure><p><a href="https://docs.pipenv.org/advanced/#caveats" target="_blank" rel="external">官方文档</a>还介绍了一些其他的命令，感兴趣的可以翻阅一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pipenv&lt;/code&gt;是&lt;code&gt;requests&lt;/code&gt;作者的一个项目, 整合了&lt;code&gt;virtualenv&lt;/code&gt;, &lt;code&gt;pip&lt;/code&gt;, &lt;code&gt;pipfile&lt;/code&gt;, 用于更方便地为项目建立虚拟环境并管理虚拟环境中的第三方模块。&lt;/p&gt;
&lt;p&gt;为什么用&lt;code&gt;pipenv&lt;/code&gt;取代&lt;code&gt;virtualenv&lt;/code&gt;呢，参照&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32913361&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;提出了&lt;code&gt;virtualenv&lt;/code&gt;的几个缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须手动安装或删除某些特定版本的包，并记得定期更新requirements.txt文件，以保持项目环境的一致&lt;/li&gt;
&lt;li&gt;有时项目中需要有多个requirements.txt文件，比如开发时应该用dev-requirements.txt，现有的模式不能满足这些复杂的需要&lt;/li&gt;
&lt;li&gt;卸载包的时候只是卸载包自己，不能处理相关依赖，时间久了项目环境就混乱了&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>电信思考</title>
    <link href="http://yoursite.com/2018/05/26/%E7%94%B5%E4%BF%A1%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/05/26/电信思考/</id>
    <published>2018-05-26T13:38:46.000Z</published>
    <updated>2018-06-02T04:33:54.049Z</updated>
    
    <content type="html"><![CDATA[<p>今天前往电信营业厅办理宽带业务，排队排了一个小时，业务办理10分钟，在排队之余，观察起营业厅的状况，今天是周六，营业厅10个坐席有5位值班人员，在我观察的1个小时中，他们的业务状态如下：</p><ul><li>1号：接待4位客户A1-A4，办理时间分别是16、23、7、15，总计61；</li><li>2号：接待3位客户B1-B3，办理时间分别是12、25、 11，总计48；</li><li>3号：接待2位客户C1-C2，办理时间分别是20、13，总计33；</li><li>4号：接待3位客户D1-D3，办理时间分别是18、24、13，总计55；</li><li>5号：接待1位客户E1，办理时间是45，总计45；</li></ul><p>感觉营业厅就像是CPU，每一位办理业务的客户就是CPU中的一个作业，营业厅选择的作业调度模式是先来先服务(FCFS)模式，保证先来的客户先收到服务，我们知道CPU作业调度中还有一种短作业优先(SJF)模式，那么我们能否根据这两种调度模式尝试优化营业厅坐席业务流程呢？</p><a id="more"></a><p>我们将5位坐席人员调整如下：</p><ul><li>1号：处理小于15分钟内的业务；</li><li>2号：处理15-20分钟内的业务；</li><li>3号：处理大于20分钟的业务，每任务限时30分钟；</li><li>4号：处理大于20分钟的业务，每任务限时40分钟；</li><li>5号：浮动，1-4号办理业务超时时立即接手后续的客户</li></ul><p>那么客户的分配如下：</p><ul><li>1号：A3、A4、B1、B3、C2，总计耗时7+15+12+13=47，比原始模式节省了14分钟</li><li>2号：A1、D1，总计耗时16+18=34，比原始模式节省了14分钟</li><li>3号：A2、B2，总计耗时23+25=48，比原始模式增加了15分钟</li><li>4号：C1、D2、E1，总计耗时20+24+45=85，比原始模式增加了30分钟</li><li>5号：浮动，总耗时0</li></ul><p>这种情况下虽然有提升的情况(1号，用更少的时间接待了更多的人)，但也有劣化的情况(4号，同样的人数用了更多的时间)，那么有没有更好的方法呢？</p><p><a href="http://www.docin.com/p-1373624360.html" target="_blank" rel="external">营业厅排队等待问题分析与解决办法</a>这篇文章介绍了排队等待的造成因素有哪些，提出了提高效率、优化管理等方式，个人感觉治标不治本，如何提升效率？如何优化管理？业务员已经满负载运行的情况下再如何提升？大堂经理走动巡堂只能满足小部分需求，无法真正优化管理流程；<a href="https://wenku.baidu.com/view/07e866991a37f111f1855ba1.html" target="_blank" rel="external">中国移动营业厅排队服务流程分析</a>这篇文章介绍了一种大厅经理导流的方法，缺陷依然如上；<a href="http://www.doc88.com/p-9965172746565.html" target="_blank" rel="external">基于需求管理的电信营业厅排队优化措施</a>这篇文章介绍了一种基于业务时间的优化方法，并用具体的例子进行了论证，但文章缺失较多，参考价值不大，写到这里，我自己也似乎有点泄气，专家都解决不了的办法难道凭你坐在沙发上脑子转转就能解决吗？</p><p>如果我不能完全解决这个问题，那么至少我可以提出我的一些想法吧，我觉得用有一个最关键的前提，是需要提前知道客户办理的业务需要多少时间，这里我想出的方案有两个方向：</p><ul><li><p>优化取号机器</p><p>当前的取号机可以说非常原始，往往只分了几个简单的类别，是不是可以在深深度挖掘一下历史客户的业务行为，客户办理什么业务，他的诉求是什么，过程中衍生着办理了什么需求，根据这个优化取号机的交互界面，比如我就是单纯的要退订一个宽带，那么交互的逻辑就应该是“业务办理与退订—宽带业务—退订—是否还需办理其他业务—无—确认”，出来的号单应该提示我需要准备哪些材料，不清楚的可以和大堂经理咨询，从源头上先预判客户业务办理的时间。</p></li><li><p>将数据统计思维融入业务办理过程</p><p>每个业务员办理不同业务的时间的分布是怎样的？每个业务员擅长的业务是什么样的？不同年龄客户办理同一个业务所需要的时间是怎样的？简单的数据统计就可以回答上述问题，根据不同业务的类型、时间、频次分布合理的安排值班人员，根据不同业务人员的特长、熟练度、层次优化业务接待流程，根据不同的客户诉求合理的安排业务员，终极的目标是业务量上去了、业务员工作量下来了、客户满意度高了。</p></li></ul><p>都说利用大数据提升服务质量，但总感觉喊口号的多，干实事的少，统计上述数据难么？不难，只是提升服务质量当前还是一种锦上添花，远不如拉取新客提升业务量这种雪中送炭来的重要。</p><p>我想每位技术人员都应该持续思考，如何用技术更好的服务客户，技术不应该浮在天上缥缈无痕，技术应该是接地气甚至应该是土气的，好的技术应该让人感到幸福，让客户收到更优质的服务，让业务人员更轻松，最后送上前段时间的一个段子，搞笑却说出了道理：</p><blockquote><p>记者：马云推出无人超市了，您怎么看？<br>记者：大妈，无人超市不是没有人这个意思，而是说，超市里没有售货员收银员等等员工了。<br>大妈：那应该叫无员工超市啊！哎，就你们这语文水平，还当记者呢？<br>记者：是是，大妈说得对，应该叫无员工超市。大妈，那您对这种新型的超市有什么看法呢？<br>大妈：超市不需要养员工了，那东西是不是更便宜啦？<br>记者：这个？我们暂时还没了解到。<br>大妈：瞧瞧你们这些记者怎么当的？老百姓最关心的问题，你们不去了解，整天只会关心马云又弄啥玩意了。我们老百姓最关心的是什么？有没有假货，是不是更便宜啦！超市里有没有员工，关我啥事？<br>记者：您不觉得无人超市的推出将会改变我们传统的购物方式吗？<br>大妈：改变啥哟？买东西不花钱啦？刷刷支付宝那也是花钱呐！<br>记者：大妈，看来您还是不能理解时代的发展潮流。<br>大妈：哟，弄个没有员工的超市就是时代潮流啦？每天都弄些专门裁剪底层员工的玩意算啥本事？有本事弄个没有老板的超市啊？<br>记者：大妈，您对马云是不是有意见啊？<br>大妈：我不是对马云有意见，是对你这种无聊的记者有意见，问问题从来都问不到点。马云改变了我们的生活，但我们要的不仅仅是改变，而是带来幸福的改变。现在很多改变不仅没有增添我们的幸福，还增添了许多烦恼！这才是你们记者应该关注的问题。</p></blockquote><p>愿科技改变生活，科技让人幸福。</p><p>(ps.文章逻辑略乱，见谅)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天前往电信营业厅办理宽带业务，排队排了一个小时，业务办理10分钟，在排队之余，观察起营业厅的状况，今天是周六，营业厅10个坐席有5位值班人员，在我观察的1个小时中，他们的业务状态如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1号：接待4位客户A1-A4，办理时间分别是16、23、7、15，总计61；&lt;/li&gt;
&lt;li&gt;2号：接待3位客户B1-B3，办理时间分别是12、25、 11，总计48；&lt;/li&gt;
&lt;li&gt;3号：接待2位客户C1-C2，办理时间分别是20、13，总计33；&lt;/li&gt;
&lt;li&gt;4号：接待3位客户D1-D3，办理时间分别是18、24、13，总计55；&lt;/li&gt;
&lt;li&gt;5号：接待1位客户E1，办理时间是45，总计45；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感觉营业厅就像是CPU，每一位办理业务的客户就是CPU中的一个作业，营业厅选择的作业调度模式是先来先服务(FCFS)模式，保证先来的客户先收到服务，我们知道CPU作业调度中还有一种短作业优先(SJF)模式，那么我们能否根据这两种调度模式尝试优化营业厅坐席业务流程呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Keras入门学习</title>
    <link href="http://yoursite.com/2017/11/13/Keras%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/11/13/Keras入门学习/</id>
    <published>2017-11-13T12:47:30.000Z</published>
    <updated>2018-06-30T06:42:52.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Keras是一个用Python编写的、高度封装的、支持Tensorflow、CNTK、Theano的神经网络库。</p><h1 id="一、Keras模型"><a href="#一、Keras模型" class="headerlink" title="一、Keras模型"></a>一、Keras模型</h1><p>“模型”是Keras的核心数据结构，有两种模型：最基础的是Sequential模型，他是网络顺序叠加形成的栈，另一种是使用函数式接口创建的更加复杂的模型。</p><a id="more"></a><h2 id="Sequential模型"><a href="#Sequential模型" class="headerlink" title="Sequential模型"></a>Sequential模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sequential模型</span></div><div class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</div><div class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Activation</div><div class="line"></div><div class="line"><span class="comment"># 创建模型</span></div><div class="line">model = Sequential()</div><div class="line"></div><div class="line"><span class="comment"># 添加网络层</span></div><div class="line">model.add(Dense(units=<span class="number">64</span>, input_dim=<span class="number">100</span>))</div><div class="line">model.add(Activation(<span class="string">'relu'</span>))</div><div class="line">model.add(Dense(units=<span class="number">10</span>))</div><div class="line">model.add(Activation(<span class="string">'softmax'</span>))</div><div class="line"></div><div class="line"><span class="comment"># 编译模型，编译模型时必须制定损失函数和优化函数</span></div><div class="line">model.compile(loss=<span class="string">'categorial_crossentropy'</span>, optimizer=<span class="string">'sgd'</span>, metrics=[<span class="string">'accuracy'</span>])</div><div class="line"><span class="comment"># keras模块化的设计原则可以灵活的设计网络结构，如：</span></div><div class="line"><span class="comment"># from keras.optimizers import SGD</span></div><div class="line"><span class="comment"># model.compile(loss='categorical_crossentropy', optimizer=SGD(lr=0.01, momentum=0.9, nesterov=True))</span></div><div class="line"></div><div class="line"><span class="comment"># 按批次训练网络</span></div><div class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>, batch_size=<span class="number">32</span>)</div><div class="line"><span class="comment"># 或者手动逐个批次的训练</span></div><div class="line"><span class="comment"># model.train_on_batch(x_batch, y_batch)</span></div><div class="line"></div><div class="line"><span class="comment"># 评估模型</span></div><div class="line">loss_and_metrics = model.evaluate(x_test, y_test, batch_size=<span class="number">128</span>)</div><div class="line"><span class="comment"># 或者预测新数据</span></div><div class="line">classes = model.predict(x_test, batch_size=<span class="number">128</span>)</div></pre></td></tr></table></figure><h2 id="Functional模型"><a href="#Functional模型" class="headerlink" title="Functional模型"></a>Functional模型</h2><p>Keras函数式模型接口是用户定义多输出模型、非循环有向模型或具有共享层的模型等复杂模型的途径。函数式模型是最广泛的一类模型，序贯模型（Sequential）只是它的一种特殊情况。</p><p><strong>全连接层模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</div><div class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</div><div class="line"></div><div class="line">inputs = Input(shape=(<span class="number">784</span>,))</div><div class="line">x = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(inputs) <span class="comment"># 第一层relu</span></div><div class="line">x = Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>)(x) <span class="comment"># 第二层relu</span></div><div class="line">predictions = Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)(x) <span class="comment"># 输出层</span></div><div class="line"></div><div class="line">model = Model(inputs=inputs, outputs=predictions)</div><div class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'categorical_crossentropy'</span>, metrics=[<span class="string">'accuracy'</span>])</div><div class="line">model.fit(data,labels)</div></pre></td></tr></table></figure><h2 id="模型通用方法"><a href="#模型通用方法" class="headerlink" title="模型通用方法"></a>模型通用方法</h2><p><code>model.summary()</code>:打印模型概况</p><p><code>model.get_config()</code>:返回包含模型配置信息的字典</p><p><code>model.get_layer()</code>:根据层名称或者下标获取层对象</p><p><code>model.set_weights()</code>:为模型赋予权重</p><p><code>model.to_json</code>:返回模型的json字符串，仅包含网络结构，不保全权重</p><p><code>model.save_weights(filepath)</code>：将模型权重保存到指定路径，文件类型是HDF5（后缀是.h5）。</p><p><code>model.load_weights(filepath, by_name=False)</code>：从HDF5文件中加载权重到当前模型中, 默认情况下模型的结构将保持不变。如果想将权重载入不同的模型（有些层相同）中，则设置<code>by_name=True</code>，只有名字匹配的层才会载入权重。</p><h2 id="Sequential模型方法"><a href="#Sequential模型方法" class="headerlink" title="Sequential模型方法"></a>Sequential模型方法</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add(self, layer)</div></pre></td></tr></table></figure><p>向模型中添加一个层</p><ul><li>layer: Layer对象</li></ul><hr><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pop(self)</div></pre></td></tr></table></figure><p>弹出模型最后的一层，无返回值</p><hr><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(self, optimizer, loss, metrics=<span class="keyword">None</span>, sample_weight_mode=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>编译用来配置模型的学习过程，其参数有</p><ul><li>optimizer：字符串（预定义优化器名）或优化器对象，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/optimizers/" target="_blank" rel="external">优化器</a></li><li>loss：字符串（预定义损失函数名）或目标函数，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/objectives/" target="_blank" rel="external">损失函数</a></li><li>metrics：列表，包含评估模型在训练和测试时的网络性能的指标，典型用法是<code>metrics=[&#39;accuracy&#39;]</code></li><li>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。在下面<code>fit</code>函数的解释中有相关的参考内容。</li><li>kwargs：使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.add(Dense(<span class="number">32</span>, input_shape=(<span class="number">500</span>,)))</div><div class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</div><div class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</div><div class="line">      loss=<span class="string">'categorical_crossentropy'</span>,</div><div class="line">      metrics=[<span class="string">'accuracy'</span>])</div></pre></td></tr></table></figure><p>模型在使用前必须编译，否则在调用fit或evaluate时会抛出异常。</p><h3 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit(self, x, y, batch_size=<span class="number">32</span>, epochs=<span class="number">10</span>, verbose=<span class="number">1</span>, callbacks=<span class="keyword">None</span>, validation_split=<span class="number">0.0</span>, validation_data=<span class="keyword">None</span>, shuffle=<span class="keyword">True</span>, class_weight=<span class="keyword">None</span>, sample_weight=<span class="keyword">None</span>, initial_epoch=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>本函数将模型训练<code>nb_epoch</code>轮，其参数有：</p><ul><li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array</li><li>y：标签，numpy array</li><li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li><li>epochs：整数，训练的轮数，每个epoch会把训练集轮一遍。</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>callbacks：list，其中的元素是<code>keras.callbacks.Callback</code>的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/" target="_blank" rel="external">回调函数</a></li><li>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之前，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。</li><li>validation_data：形式为（X，y）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li><li>shuffle：布尔值或字符串，一般为布尔值，表示是否在训练过程中随机打乱输入样本的顺序。若为字符串“batch”，则是用来处理HDF5数据的特殊情况，它将在batch内部将数据打乱。</li><li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p><code>fit</code>函数返回一个<code>History</code>的对象，其<code>History.history</code>属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况</p><hr><p>evaluate</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate(self, x, y, batch_size=<span class="number">32</span>, verbose=<span class="number">1</span>, sample_weight=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>本函数按batch计算在某些输入数据上模型的误差，其参数有：</p><ul><li>x：输入数据，与<code>fit</code>一样，是numpy array或numpy array的list</li><li>y：标签，numpy array</li><li>batch_size：整数，含义同<code>fit</code>的同名参数</li><li>verbose：含义同<code>fit</code>的同名参数，但只能取0或1</li><li>sample_weight：numpy array，含义同<code>fit</code>的同名参数</li></ul><p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。<code>model.metrics_names</code>将给出list中各个值的含义。</p><p>如果没有特殊说明，以下函数的参数均保持与<code>fit</code>的同名参数相同的含义</p><p>如果没有特殊说明，以下函数的verbose参数（如果有）均只能取0或1</p><hr><h3 id="predict"><a href="#predict" class="headerlink" title="predict"></a>predict</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict(self, x, batch_size=<span class="number">32</span>, verbose=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>本函数按batch获得输入数据对应的输出，其参数有：</p><p>函数的返回值是预测值的numpy array</p><hr><h3 id="train-on-batch"><a href="#train-on-batch" class="headerlink" title="train_on_batch"></a>train_on_batch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train_on_batch(self, x, y, class_weight=<span class="keyword">None</span>, sample_weight=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>本函数在一个batch的数据上进行一次参数更新</p><p>函数返回训练误差的标量值或标量值的list，与<a href="https://keras-cn.readthedocs.io/en/latest/models/sequential/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同。</p><hr><h3 id="test-on-batch"><a href="#test-on-batch" class="headerlink" title="test_on_batch"></a>test_on_batch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test_on_batch(self, x, y, sample_weight=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行评估</p><p>函数的返回与<a href="https://keras-cn.readthedocs.io/en/latest/models/sequential/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同</p><hr><h3 id="predict-on-batch"><a href="#predict-on-batch" class="headerlink" title="predict_on_batch"></a>predict_on_batch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict_on_batch(self, x)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行测试</p><p>函数返回模型在一个batch上的预测结果</p><hr><h3 id="fit-generator"><a href="#fit-generator" class="headerlink" title="fit_generator"></a>fit_generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit_generator(self, generator, steps_per_epoch, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, callbacks=<span class="keyword">None</span>, validation_data=<span class="keyword">None</span>, validation_steps=<span class="keyword">None</span>, class_weight=<span class="keyword">None</span>, max_q_size=<span class="number">10</span>, workers=<span class="number">1</span>, pickle_safe=<span class="keyword">False</span>, initial_epoch=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>利用Python的生成器，逐个生成数据的batch并进行训练。生成器与模型将并行执行以提高效率。例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练</p><p>函数的参数是：</p><ul><li>generator：生成器函数，生成器的输出应该为：<ul><li>一个形如（inputs，targets）的tuple</li><li>一个形如（inputs, targets,sample_weight）的tuple。所有的返回值都应该包含相同数目的样本。生成器将无限在数据集上循环。每个epoch以经过模型的样本数达到<code>samples_per_epoch</code>时，记一个epoch结束</li></ul></li><li>steps_per_epoch：整数，当生成器返回<code>steps_per_epoch</code>次数据时计一个epoch结束，执行下一个epoch</li><li>epochs：整数，数据迭代的轮数</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>validation_data：具有以下三种形式之一<ul><li>生成验证集的生成器</li><li>一个形如（inputs,targets）的tuple</li><li>一个形如（inputs,targets，sample_weights）的tuple</li></ul></li><li>validation_steps: 当validation_data为生成器时，本参数指定验证集的生成器返回次数</li><li>class_weight：规定类别权重的字典，将类别映射为权重，常用于处理样本不均衡问题。</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>workers：最大进程数</li><li>max_q_size：生成器队列的最大容量</li><li>pickle_safe: 若为真，则使用基于进程的线程。由于该实现依赖多进程，不能传递non picklable（无法被pickle序列化）的参数到生成器中，因为无法轻易将它们传入子进程中。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p>函数返回一个<code>History</code>对象</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_arrays_from_file</span><span class="params">(path)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">            f = open(path)</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                <span class="comment"># create Numpy arrays of input data</span></div><div class="line">                <span class="comment"># and labels, from each line in the file</span></div><div class="line">                x, y = process_line(line)</div><div class="line">                <span class="keyword">yield</span> (x, y)</div><div class="line">        f.close()</div><div class="line"></div><div class="line">model.fit_generator(generate_arrays_from_file(<span class="string">'/my_file.txt'</span>),</div><div class="line">        samples_per_epoch=<span class="number">10000</span>, epochs=<span class="number">10</span>)</div></pre></td></tr></table></figure><hr><h3 id="evaluate-generator"><a href="#evaluate-generator" class="headerlink" title="evaluate_generator"></a>evaluate_generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate_generator(self, generator, steps, max_q_size=<span class="number">10</span>, workers=<span class="number">1</span>, pickle_safe=<span class="keyword">False</span>)</div></pre></td></tr></table></figure><p>本函数使用一个生成器作为数据源评估模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。该函数的参数与<code>fit_generator</code>同名参数含义相同，steps是生成器要返回数据的轮数。</p><hr><h3 id="predcit-generator"><a href="#predcit-generator" class="headerlink" title="predcit_generator"></a>predcit_generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict_generator(self, generator, steps, max_q_size=<span class="number">10</span>, workers=<span class="number">1</span>, pickle_safe=<span class="keyword">False</span>, verbose=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>本函数使用一个生成器作为数据源预测模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。该函数的参数与<code>fit_generator</code>同名参数含义相同，steps是生成器要返回数据的轮数。</p><h2 id="函数式模型接口"><a href="#函数式模型接口" class="headerlink" title="函数式模型接口"></a>函数式模型接口</h2><p>Keras的函数式模型为<code>Model</code>，即广义的拥有输入和输出的模型，我们使用<code>Model</code>来初始化一个函数式模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from keras.models import Model</div><div class="line">from keras.layers import Input, Dense</div><div class="line"></div><div class="line">a = Input(shape=(32,))</div><div class="line">b = Dense(32)(a)</div><div class="line">model = Model(inputs=a, outputs=b)</div></pre></td></tr></table></figure><p>在这里，我们的模型以<code>a</code>为输入，以<code>b</code>为输出，同样我们可以构造拥有多输入和多输出的模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">model = Model(inputs=[a1, a2], outputs=[b1, b3, b3])</div></pre></td></tr></table></figure><hr><h3 id="Model模型方法"><a href="#Model模型方法" class="headerlink" title="Model模型方法"></a>Model模型方法</h3><h3 id="compile-1"><a href="#compile-1" class="headerlink" title="compile"></a>compile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile(self, optimizer, loss, metrics=None, loss_weights=None, sample_weight_mode=None)</div></pre></td></tr></table></figure><p>本函数编译模型以供训练，参数有</p><ul><li>optimizer：优化器，为预定义优化器名或优化器对象，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/optimizers/" target="_blank" rel="external">优化器</a></li><li>loss：损失函数，为预定义损失函数名或一个目标函数，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/objectives/" target="_blank" rel="external">损失函数</a></li><li>metrics：列表，包含评估模型在训练和测试时的性能的指标，典型用法是<code>metrics=[&#39;accuracy&#39;]</code>如果要在多输出模型中为不同的输出指定不同的指标，可像该参数传递一个字典，例如<code>metrics={&#39;ouput_a&#39;: &#39;accuracy&#39;}</code></li><li>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。如果模型有多个输出，可以向该参数传入指定sample_weight_mode的字典或列表。在下面<code>fit</code>函数的解释中有相关的参考内容。</li><li>kwargs：使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function</li></ul><p>当为参数传入非法值时会抛出异常</p><p>【Tips】如果你只是载入模型并利用其predict，可以不用进行compile。在Keras中，compile主要完成损失函数和优化器的一些配置，是为训练服务的。predict会在内部进行符号函数的编译工作（通过调用_make_predict_function生成函数），</p><hr><h3 id="fit-1"><a href="#fit-1" class="headerlink" title="fit"></a>fit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit(self, x=None, y=None, batch_size=32, epochs=1, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0)</div></pre></td></tr></table></figure><p>本函数用以训练模型，参数有：</p><ul><li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array。如果模型的每个输入都有名字，则可以传入一个字典，将输入名与其输入数据对应起来。</li><li>y：标签，numpy array。如果模型有多个输出，可以传入一个numpy array的list。如果模型的输出拥有名字，则可以传入一个字典，将输出名与其标签对应起来。</li><li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li><li>nb_epoch：整数，训练的轮数，训练数据将会被遍历nb_epoch次。Keras中nb开头的变量均为”number of”的意思</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>callbacks：list，其中的元素是<code>keras.callbacks.Callback</code>的对象。这个list中的回调函数将会在训练过程中的适当时机被调用，参考<a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/" target="_blank" rel="external">回调函数</a></li><li>validation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。注意，validation_split的划分在shuffle之后，因此如果你的数据本身是有序的，需要先手工打乱再指定validation_split，否则可能会出现验证集样本不均匀。</li><li>validation_data：形式为（X，y）或（X，y，sample_weights）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li><li>shuffle：布尔值，表示是否在训练过程中每个epoch前随机打乱输入样本的顺序。</li><li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）。该参数在处理非平衡的训练数据（某些类的训练样本数很少）时，可以使得损失函数对样本数不足的数据更加关注。</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p>输入数据与规定数据不匹配时会抛出错误</p><p><code>fit</code>函数返回一个<code>History</code>的对象，其<code>History.history</code>属性记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标变化情况</p><hr><p>evaluate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate(self, x, y, batch_size=32, verbose=1, sample_weight=None)</div></pre></td></tr></table></figure><p>本函数按batch计算在某些输入数据上模型的误差，其参数有：</p><ul><li>x：输入数据，与<code>fit</code>一样，是numpy array或numpy array的list</li><li>y：标签，numpy array</li><li>batch_size：整数，含义同<code>fit</code>的同名参数</li><li>verbose：含义同<code>fit</code>的同名参数，但只能取0或1</li><li>sample_weight：numpy array，含义同<code>fit</code>的同名参数</li></ul><p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。<code>model.metrics_names</code>将给出list中各个值的含义。</p><p>如果没有特殊说明，以下函数的参数均保持与<code>fit</code>的同名参数相同的含义</p><p>如果没有特殊说明，以下函数的verbose参数（如果有）均只能取0或1</p><hr><h3 id="predict-1"><a href="#predict-1" class="headerlink" title="predict"></a>predict</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict(self, x, batch_size=32, verbose=0)</div></pre></td></tr></table></figure><p>本函数按batch获得输入数据对应的输出，其参数有：</p><p>函数的返回值是预测值的numpy array</p><hr><h3 id="train-on-batch-1"><a href="#train-on-batch-1" class="headerlink" title="train_on_batch"></a>train_on_batch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train_on_batch(self, x, y, class_weight=None, sample_weight=None)</div></pre></td></tr></table></figure><p>本函数在一个batch的数据上进行一次参数更新</p><p>函数返回训练误差的标量值或标量值的list，与<a href="https://keras-cn.readthedocs.io/en/latest/models/model/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同。</p><hr><h3 id="test-on-batch-1"><a href="#test-on-batch-1" class="headerlink" title="test_on_batch"></a>test_on_batch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test_on_batch(self, x, y, sample_weight=None)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行评估</p><p>函数的返回与<a href="https://keras-cn.readthedocs.io/en/latest/models/model/#evaluate" target="_blank" rel="external">evaluate</a>的情形相同</p><hr><h3 id="predict-on-batch-1"><a href="#predict-on-batch-1" class="headerlink" title="predict_on_batch"></a>predict_on_batch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">predict_on_batch(self, x)</div></pre></td></tr></table></figure><p>本函数在一个batch的样本上对模型进行测试</p><p>函数返回模型在一个batch上的预测结果</p><hr><h3 id="fit-generator-1"><a href="#fit-generator-1" class="headerlink" title="fit_generator"></a>fit_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)</div></pre></td></tr></table></figure><p>利用Python的生成器，逐个生成数据的batch并进行训练。生成器与模型将并行执行以提高效率。例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练</p><p>函数的参数是：</p><ul><li>generator：生成器函数，生成器的输出应该为：<ul><li>一个形如（inputs，targets）的tuple</li><li>一个形如（inputs, targets,sample_weight）的tuple。所有的返回值都应该包含相同数目的样本。生成器将无限在数据集上循环。每个epoch以经过模型的样本数达到<code>samples_per_epoch</code>时，记一个epoch结束</li></ul></li><li>steps_per_epoch：整数，当生成器返回<code>steps_per_epoch</code>次数据时计一个epoch结束，执行下一个epoch</li><li>epochs：整数，数据迭代的轮数</li><li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li><li>validation_data：具有以下三种形式之一<ul><li>生成验证集的生成器</li><li>一个形如（inputs,targets）的tuple</li><li>一个形如（inputs,targets，sample_weights）的tuple</li></ul></li><li>validation_steps: 当validation_data为生成器时，本参数指定验证集的生成器返回次数</li><li>class_weight：规定类别权重的字典，将类别映射为权重，常用于处理样本不均衡问题。</li><li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode=&#39;temporal&#39;</code>。</li><li>workers：最大进程数</li><li>max_q_size：生成器队列的最大容量</li><li>pickle_safe: 若为真，则使用基于进程的线程。由于该实现依赖多进程，不能传递non picklable（无法被pickle序列化）的参数到生成器中，因为无法轻易将它们传入子进程中。</li><li>initial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。</li></ul><p>函数返回一个<code>History</code>对象</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def generate_arrays_from_file(path):</div><div class="line">    while 1:</div><div class="line">    f = open(path)</div><div class="line">    for line in f:</div><div class="line">        # create numpy arrays of input data</div><div class="line">        # and labels, from each line in the file</div><div class="line">        x1, x2, y = process_line(line)</div><div class="line">        yield (&#123;&apos;input_1&apos;: x1, &apos;input_2&apos;: x2&#125;, &#123;&apos;output&apos;: y&#125;)</div><div class="line">    f.close()</div><div class="line"></div><div class="line">model.fit_generator(generate_arrays_from_file(&apos;/my_file.txt&apos;),</div><div class="line">        steps_per_epoch=10000, epochs=10)</div></pre></td></tr></table></figure><hr><h3 id="evaluate-generator-1"><a href="#evaluate-generator-1" class="headerlink" title="evaluate_generator"></a>evaluate_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evaluate_generator(self, generator, steps, max_q_size=10, workers=1, pickle_safe=False)</div></pre></td></tr></table></figure><p>本函数使用一个生成器作为数据源，来评估模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。</p><p>函数的参数是：</p><ul><li>generator：生成输入batch数据的生成器</li><li>val_samples：生成器应该返回的总样本数</li><li>steps：生成器要返回数据的轮数</li><li>max_q_size：生成器队列的最大容量</li><li>nb_worker：使用基于进程的多线程处理时的进程数</li><li>pickle_safe：若设置为True，则使用基于进程的线程。注意因为它的实现依赖于多进程处理，不可传递不可pickle的参数到生成器中，因为它们不能轻易的传递到子进程中。</li></ul><hr><h3 id="predict-generator"><a href="#predict-generator" class="headerlink" title="predict_generator"></a>predict_generator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)</div></pre></td></tr></table></figure><p>从一个生成器上获取数据并进行预测，生成器应返回与<code>predict_on_batch</code>输入类似的数据</p><p>函数的参数是：</p><ul><li><p>generator：生成输入batch数据的生成器</p></li><li><p>val_samples：生成器应该返回的总样本数</p></li><li><p>max_q_size：生成器队列的最大容量</p></li><li><p>nb_worker：使用基于进程的多线程处理时的进程数</p></li><li><p>pickle_safe：若设置为True，则使用基于进程的线程。注意因为它的实现依赖于多进程处理，不可传递不可pickle的参数到生成器中，因为它们不能轻易的传递到子进程中。</p></li></ul><hr><h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><h2 id="1、常用层core"><a href="#1、常用层core" class="headerlink" title="1、常用层core"></a>1、常用层core</h2><p>常用层对应于core模块，core内部定义了一系列常用的网络层，包括全连接、激活层等</p><h3 id="Dense层"><a href="#Dense层" class="headerlink" title="Dense层"></a>Dense层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Dense(units, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>Dense就是常用的全连接层，所实现的运算是<code>output = activation(dot(input, kernel)+bias)</code>。其中<code>activation</code>是逐元素计算的激活函数，<code>kernel</code>是本层的权值矩阵，<code>bias</code>为偏置向量，只有当<code>use_bias=True</code>才会添加。</p><p>如果本层的输入数据的维度大于2，则会先被压为与<code>kernel</code>相匹配的大小。</p><p>参数含义如下：</p><ul><li>units：大于0的整数，代表该层的输出维度。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>use_bias: 布尔值，是否使用偏置项</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="Activation层"><a href="#Activation层" class="headerlink" title="Activation层"></a>Activation层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Activation(activation)</div></pre></td></tr></table></figure><p>激活层对一个层的输出施加激活函数</p><p>参数</p><ul><li>activation：将要使用的激活函数，为预定义激活函数名或一个Tensorflow/Theano的函数。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a></li></ul><p>输入shape：任意，当使用激活层作为第一层时，要指定<code>input_shape</code></p><p>输出shape：与输入shape相同</p><h3 id="Dropout层"><a href="#Dropout层" class="headerlink" title="Dropout层"></a>Dropout层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Dropout(rate, noise_shape=None, seed=None)</div></pre></td></tr></table></figure><p>为输入数据施加Dropout。Dropout将在训练过程中每次更新参数时按一定概率（rate）随机断开输入神经元，Dropout层用于防止过拟合。</p><p>参数</p><ul><li>rate：0~1的浮点数，控制需要断开的神经元的比例</li><li>noise_shape：整数张量，为将要应用在输入上的二值Dropout mask的shape，例如你的输入为(batch_size, timesteps, features)，并且你希望在各个时间步上的Dropout mask都相同，则可传入noise_shape=(batch_size, 1, features)。</li><li>seed：整数，使用的随机数种子</li></ul><h3 id="Flatten层"><a href="#Flatten层" class="headerlink" title="Flatten层"></a>Flatten层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Flatten()</div></pre></td></tr></table></figure><p>Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">model = Sequential()</div><div class="line">model.add(Convolution2D(64, 3, 3,</div><div class="line">            border_mode=&apos;same&apos;,</div><div class="line">            input_shape=(3, 32, 32)))</div><div class="line"># now: model.output_shape == (None, 64, 32, 32)</div><div class="line"></div><div class="line">model.add(Flatten())</div><div class="line"># now: model.output_shape == (None, 65536)</div></pre></td></tr></table></figure><h3 id="Reshape层"><a href="#Reshape层" class="headerlink" title="Reshape层"></a>Reshape层</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.core.Reshape(target_shape)</div></pre></td></tr></table></figure><p>Reshape层用来将输入shape转换为特定的shape</p><p>参数</p><ul><li><p>target_shape：目标shape，为整数的tuple，不包含样本数目的维度（batch大小）</p><p>输入shape:任意，但输入的shape必须固定。当使用该层为模型首层时，需要指定<code>input_shape</code>参数</p></li></ul><p>输出shape:<code>(batch_size,)+target_shape</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># as first layer in a Sequential model</div><div class="line">model = Sequential()</div><div class="line">model.add(Reshape((3, 4), input_shape=(12,)))</div><div class="line"># now: model.output_shape == (None, 3, 4)</div><div class="line"># note: `None` is the batch dimension</div><div class="line"></div><div class="line"># as intermediate layer in a Sequential model</div><div class="line">model.add(Reshape((6, 2)))</div><div class="line"># now: model.output_shape == (None, 6, 2)</div><div class="line"></div><div class="line"># also supports shape inference using `-1` as dimension</div><div class="line">model.add(Reshape((-1, 2, 2)))</div><div class="line"># now: model.output_shape == (None, 3, 2, 2)</div></pre></td></tr></table></figure><h3 id="Permute层"><a href="#Permute层" class="headerlink" title="Permute层"></a>Permute层</h3><p>将输入的维度按照给定的模式进行重排。</p><h3 id="RepeatVector层"><a href="#RepeatVector层" class="headerlink" title="RepeatVector层"></a>RepeatVector层</h3><p>将输入层重复n次。</p><h3 id="Lambda层"><a href="#Lambda层" class="headerlink" title="Lambda层"></a>Lambda层</h3><p>对上一层的输出施以某个表达式。</p><h3 id="ActivityRegularizer层"><a href="#ActivityRegularizer层" class="headerlink" title="ActivityRegularizer层"></a>ActivityRegularizer层</h3><p>经过本层的数据不会有任何变化，但会基于其激活值更新损失函数值。<br>参数：<br>l1：1范数正则因子（正浮点数）<br>l2：2范数正则因子（正浮点数）<br>输入shape：任意，当使用该层作为第一层时，要指定input_shape<br>输出shape：与输入shape相同</p><h3 id="Masking层"><a href="#Masking层" class="headerlink" title="Masking层"></a>Masking层</h3><p>使用给定的值对输入的序列信号进行“屏蔽”，用以定位需要跳过的时间步</p><h2 id="2、卷积层"><a href="#2、卷积层" class="headerlink" title="2、卷积层"></a>2、卷积层</h2><h3 id="Conv1D层"><a href="#Conv1D层" class="headerlink" title="Conv1D层"></a><strong>Conv1D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv1D(filters, kernel_size, strides=<span class="number">1</span>, padding=<span class="string">'valid'</span>, dilation_rate=<span class="number">1</span>, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>一维卷积层（即时域卷积），用以在一维输入信号上进行邻域滤波。当使用该层作为首层时，需要提供关键字参数<code>input_shape</code>。例如<code>(10,128)</code>代表一个长为10的序列，序列中每个信号为128向量。而<code>(None, 128)</code>代表变长的128维向量序列。</p><p>该层生成将输入信号与卷积核按照单一的空域（或时域）方向进行卷积。如果<code>use_bias=True</code>，则还会加上一个偏置项，若<code>activation</code>不为None，则输出为经过激活函数的输出。</p><p>参数</p><ul><li>filters：卷积核的数目（即输出的维度）</li><li>kernel_size：整数或由单个整数构成的list/tuple，卷积核的空域或时域窗长度</li><li>strides：整数或由单个整数构成的list/tuple，为卷积的步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li><li>padding：补0策略，为“valid”, “same” 或“causal”，“causal”将产生因果（膨胀的）卷积，即output[t]不依赖于input[t+1：]。当对不能违反时间顺序的时序信号建模时有用。参考<a href="https://arxiv.org/abs/1609.03499" target="_blank" rel="external">WaveNet: A Generative Model for Raw Audio, section 2.1.</a>。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>dilation_rate：整数或由单个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li><li>use_bias:布尔值，是否使用偏置项</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="Conv2D层"><a href="#Conv2D层" class="headerlink" title="Conv2D层"></a><strong>Conv2D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv2D(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, dilation_rate=(<span class="number">1</span>, <span class="number">1</span>), activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>二维卷积层，即对图像的空域卷积。该层对二维输入进行滑动窗卷积，当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (128,128,3)</code>代表128*128的彩色RGB图像（<code>data_format=&#39;channels_last&#39;</code>）</p><p>参数</p><ul><li>filters：卷积核的数目（即输出的维度）</li><li>kernel_size：单个整数或由两个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li><li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li><li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>dilation_rate：单个整数或由两个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li><li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是<code>~/.keras/keras.json</code>中设置的值，若从未设置过，则为“channels_last”。</li><li>use_bias:布尔值，是否使用偏置项</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="SeparableConv2D层"><a href="#SeparableConv2D层" class="headerlink" title="SeparableConv2D层"></a><strong>SeparableConv2D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.SeparableConv2D(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, depth_multiplier=<span class="number">1</span>, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, depthwise_initializer=<span class="string">'glorot_uniform'</span>, pointwise_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, depthwise_regularizer=<span class="keyword">None</span>, pointwise_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, depthwise_constraint=<span class="keyword">None</span>, pointwise_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>该层是在深度方向上的可分离卷积。</p><p>可分离卷积首先按深度方向进行卷积（对每个输入通道分别卷积），然后逐点进行卷积，将上一步的卷积结果混合到输出通道中。参数<code>depth_multiplier</code>控制了在depthwise卷积（第一步）的过程中，每个输入通道信号产生多少个输出通道。</p><p>直观来说，可分离卷积可以看做讲一个卷积核分解为两个小的卷积核，或看作Inception模块的一种极端情况。</p><p>当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (3,128,128)</code>代表128*128的彩色RGB图像</p><p>参数</p><ul><li>filters：卷积核的数目（即输出的维度）</li><li>kernel_size：单个整数或由两个个整数构成的list/tuple，卷积核的宽度和长度。如为单个整数，则表示在各个空间维度的相同长度。</li><li>strides：单个整数或由两个整数构成的list/tuple，为卷积的步长。如为单个整数，则表示在各个空间维度的相同步长。任何不为1的strides均与任何不为1的dilation_rate均不兼容</li><li>padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同。</li><li>activation：激活函数，为预定义的激活函数名（参考<a href="https://keras-cn.readthedocs.io/en/latest/other/activations" target="_blank" rel="external">激活函数</a>），或逐元素（element-wise）的Theano函数。如果不指定该参数，将不会使用任何激活函数（即使用线性激活函数：a(x)=x）</li><li>dilation_rate：单个整数或由两个个整数构成的list/tuple，指定dilated convolution中的膨胀比例。任何不为1的dilation_rate均与任何不为1的strides均不兼容。</li><li>data_format：字符串，“channels_first”或“channels_last”之一，代表图像的通道维的位置。该参数是Keras 1.x中的image_dim_ordering，“channels_last”对应原本的“tf”，“channels_first”对应原本的“th”。以128x128的RGB图像为例，“channels_first”应将数据组织为（3,128,128），而“channels_last”应将数据组织为（128,128,3）。该参数的默认值是<code>~/.keras/keras.json</code>中设置的值，若从未设置过，则为“channels_last”。</li><li>use_bias:布尔值，是否使用偏置项</li><li>depth_multiplier：在按深度卷积的步骤中，每个输入通道使用多少个输出通道</li><li>kernel_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>bias_initializer：权值初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考<a href="https://keras-cn.readthedocs.io/en/latest/other/initializations" target="_blank" rel="external">initializers</a></li><li>depthwise_regularizer：施加在按深度卷积的权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>pointwise_regularizer：施加在按点卷积的权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_regularizer：施加在权重上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>bias_regularizer：施加在偏置向量上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>activity_regularizer：施加在输出上的正则项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/regularizers" target="_blank" rel="external">Regularizer</a>对象</li><li>kernel_constraints：施加在权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>bias_constraints：施加在偏置上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>depthwise_constraint：施加在按深度卷积权重上的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li><li>pointwise_constraint施加在按点卷积权重的约束项，为<a href="https://keras-cn.readthedocs.io/en/latest/other/constraints" target="_blank" rel="external">Constraints</a>对象</li></ul><h3 id="Conv2DTranspos层"><a href="#Conv2DTranspos层" class="headerlink" title="Conv2DTranspos层"></a><strong>Conv2DTranspos层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv2DTranspose(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>该层是转置的卷积操作（反卷积）。需要反卷积的情况通常发生在用户想要对一个普通卷积的结果做反方向的变换。例如，将具有该卷积层输出shape的tensor转换为具有该卷积层输入shape的tensor。同时保留与卷积层兼容的连接模式。</p><p>当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (3,128,128)</code>代表128*128的彩色RGB图像</p><h3 id="Conv3D层"><a href="#Conv3D层" class="headerlink" title="Conv3D层"></a><strong>Conv3D层</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keras.layers.convolutional.Conv3D(filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="keyword">None</span>, dilation_rate=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), activation=<span class="keyword">None</span>, use_bias=<span class="keyword">True</span>, kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>, kernel_regularizer=<span class="keyword">None</span>, bias_regularizer=<span class="keyword">None</span>, activity_regularizer=<span class="keyword">None</span>, kernel_constraint=<span class="keyword">None</span>, bias_constraint=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>三维卷积对三维的输入进行滑动窗卷积，当使用该层作为第一层时，应提供<code>input_shape</code>参数。例如<code>input_shape = (3,10,128,128)</code>代表对10帧128*128的彩色RGB图像进行卷积。数据的通道位置仍然有<code>data_format</code>参数指定。</p><h3 id="Cropping1D层"><a href="#Cropping1D层" class="headerlink" title="Cropping1D层"></a><strong>Cropping1D层</strong></h3><p>在时间轴（axis1）上对1D输入（即时间序列）进行裁剪</p><h3 id="Cropping2D层"><a href="#Cropping2D层" class="headerlink" title="Cropping2D层"></a><strong>Cropping2D层</strong></h3><p>对2D输入（图像）进行裁剪，将在空域维度，即宽和高的方向上裁剪</p><h3 id="Cropping3D层"><a href="#Cropping3D层" class="headerlink" title="Cropping3D层"></a><strong>Cropping3D层</strong></h3><p>对2D输入（图像）进行裁剪</p><h3 id="UpSampling1D层"><a href="#UpSampling1D层" class="headerlink" title="UpSampling1D层"></a><strong>UpSampling1D层</strong></h3><p>在时间轴上，将每个时间步重复<code>length</code>次</p><h3 id="UpSampling2D层"><a href="#UpSampling2D层" class="headerlink" title="UpSampling2D层"></a><strong>UpSampling2D层</strong></h3><p>将数据的行和列分别重复size[0]和size[1]次</p><h3 id="UpSampling3D层"><a href="#UpSampling3D层" class="headerlink" title="UpSampling3D层"></a><strong>UpSampling3D层</strong></h3><p>将数据的三个维度上分别重复size[0]、size[1]和ize[2]次</p><h3 id="ZeroPadding2D层"><a href="#ZeroPadding2D层" class="headerlink" title="ZeroPadding2D层"></a><strong>ZeroPadding2D层</strong></h3><p>对2D输入（如图片）的边界填充0，以控制卷积以后特征图的大小</p><h3 id="ZeroPadding3D层"><a href="#ZeroPadding3D层" class="headerlink" title="ZeroPadding3D层"></a><strong>ZeroPadding3D层</strong></h3><p>对3个维度填充0，以控制卷积以后特征图的大小</p><h2 id="3、池化层"><a href="#3、池化层" class="headerlink" title="3、池化层"></a>3、池化层</h2><p><strong>MaxPooling1D层</strong>：对时域1D的信号进行最大值池化</p><p><strong>MaxPooling2D层</strong>：对空域1D的信号进行最大值池化</p><p><strong>MaxPooling3D层</strong>：对3D的信号进行最大值池化，本层目前只能在使用Theano为后端时可用</p><p><strong>AveragePooling1D层</strong>：对时域1D的信号进行平均值池化</p><p><strong>AveragePooling1D层</strong>：对时域1D的信号进行平均值池化</p><p><strong>AveragePooling1D层</strong>：对时域1D的信号进行平均值池化，本层目前只能在使用Theano为后端时可用</p><h2 id="4、局部连接层LocallyConnected"><a href="#4、局部连接层LocallyConnected" class="headerlink" title="4、局部连接层LocallyConnected"></a>4、局部连接层LocallyConnected</h2><p><strong>LocallyConnected1D层</strong>：<code>LocallyConnected1D</code>层与<code>Conv1D</code>工作方式类似，唯一的区别是不进行权值共享。即施加在不同输入位置的滤波器是不一样的。</p><p><strong>LocallyConnected2D层</strong>：<code>LocallyConnected2D</code>层与<code>Convolution2D</code>工作方式类似，唯一的区别是不进行权值共享。即施加在不同输入patch的滤波器是不一样的，当使用该层作为模型首层时，需要提供参数<code>input_dim</code>或<code>input_shape</code>参数。参数含义参考<code>Convolution2D</code>。</p><h2 id="5、循环层Recurrent"><a href="#5、循环层Recurrent" class="headerlink" title="5、循环层Recurrent"></a>5、循环层Recurrent</h2><p><strong>Recurrent层</strong></p><p>这是循环层的抽象类，请不要在模型中直接应用该层（因为它是抽象类，无法实例化任何对象）。请使用它的子类<code>LSTM</code>，<code>GRU</code>或<code>SimpleRNN</code>。</p><p><strong>SimpleRNN层</strong></p><p>全连接RNN网络，RNN的输出会被回馈到输入</p><h1 id="三、数据预处理"><a href="#三、数据预处理" class="headerlink" title="三、数据预处理"></a>三、数据预处理</h1><h1 id="四、网络配置"><a href="#四、网络配置" class="headerlink" title="四、网络配置"></a>四、网络配置</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://keras.io/" target="_blank" rel="external">官方文档(英文)</a></li><li><a href="https://keras-cn.readthedocs.io/en/latest/" target="_blank" rel="external">官方文档(中文)</a></li><li><a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf" target="_blank" rel="external">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Keras是一个用Python编写的、高度封装的、支持Tensorflow、CNTK、Theano的神经网络库。&lt;/p&gt;
&lt;h1 id=&quot;一、Keras模型&quot;&gt;&lt;a href=&quot;#一、Keras模型&quot; class=&quot;headerlink&quot; title=&quot;一、Keras模型&quot;&gt;&lt;/a&gt;一、Keras模型&lt;/h1&gt;&lt;p&gt;“模型”是Keras的核心数据结构，有两种模型：最基础的是Sequential模型，他是网络顺序叠加形成的栈，另一种是使用函数式接口创建的更加复杂的模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Keras    机器学习   人工智能" scheme="http://yoursite.com/tags/Keras-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo学习笔记</title>
    <link href="http://yoursite.com/2017/11/05/Hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/05/Hexo学习笔记/</id>
    <published>2017-11-05T08:42:30.000Z</published>
    <updated>2018-06-30T06:43:18.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo学习笔记"><a href="#Hexo学习笔记" class="headerlink" title="Hexo学习笔记"></a>Hexo学习笔记</h1><blockquote><p>Hexo是一个快速简洁的博客框架，使用Markdown解析文章，将内容生成静态网页，配合主题可以制作成精美的网页，将网页部署到github之后，你就有了一个免费的博客</p></blockquote><p>个人感觉，面向开发者而言，博客应该是记录自己点滴积累的地方，它应该足够简洁，不应该有广告等元素干扰阅读，它应该是开发友好的，对程序员而言保持双手在键盘上，给我们顺滑流畅的书写过程，最后它应该足够强大，能让我们充分折腾，如何你也有这样的想法，那么<code>Hexo</code>是一个十分不错的选择。</p><p>本文档将按照官方文档的结构顺序从头到尾从网站初始化到部署到github完整的一个流程进行详细的说明。</p><a id="more"></a><h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># step1、安装Node.js</span></div><div class="line">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</div><div class="line"><span class="comment"># 安装完成后，重启终端并执行下列命令即可安装 Node.js</span></div><div class="line">nvm install stable    </div><div class="line"></div><div class="line"><span class="comment"># step2、安装github</span></div><div class="line">sudo apt-get install git    </div><div class="line"></div><div class="line"><span class="comment"># step3、安装hexo</span></div><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure><h1 id="二、建站"><a href="#二、建站" class="headerlink" title="二、建站"></a>二、建站</h1><p>初始化一个空站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init &lt;folder&gt;</div><div class="line"><span class="built_in">cd</span> &lt;folder&gt;</div><div class="line">npm install</div></pre></td></tr></table></figure><p>初始化后的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml    <span class="comment"># 网站配置信息</span></div><div class="line">├── package.json<span class="comment"># 应用配置信息</span></div><div class="line">├── scaffolds<span class="comment"># 模板文件夹</span></div><div class="line">├── <span class="built_in">source</span><span class="comment"># 资源文件夹</span></div><div class="line">|   ├── _drafts<span class="comment"># 未发布的草稿内容</span></div><div class="line">|   └── _posts<span class="comment"># 已发布的博客文章</span></div><div class="line">└── themes<span class="comment"># 网站主题文件夹</span></div></pre></td></tr></table></figure><h2 id="2-1、常用命令"><a href="#2-1、常用命令" class="headerlink" title="2.1、常用命令"></a>2.1、常用命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新建一个网站</span></div><div class="line">hexo init [folder]    </div><div class="line"></div><div class="line"><span class="comment"># 新建一篇文章，如果不设置layout样式文件，则使用默认的配置，标题推荐用引号包起来(避免空格的问题)</span></div><div class="line">hexo new [layout] &lt;title&gt;    </div><div class="line"></div><div class="line"><span class="comment"># 生成静态文件，可选参数：</span></div><div class="line"><span class="comment"># -d，--deploy生成后部署网站</span></div><div class="line"><span class="comment"># -w，--watch监视文件变动</span></div><div class="line">hexo generate    </div><div class="line"></div><div class="line"><span class="comment"># 发布文章</span></div><div class="line">hexo publish [layout] &lt;filename&gt;</div><div class="line"></div><div class="line"><span class="comment"># 启动本地服务器，默认http://localhost:4000,参数：</span></div><div class="line"><span class="comment"># -p, --port重设端口</span></div><div class="line"><span class="comment"># -s, --static只使用静态文件</span></div><div class="line"><span class="comment"># -l, --log启动日志</span></div><div class="line">hexo server</div><div class="line"></div><div class="line"><span class="comment"># 部署网站，可选参数：</span></div><div class="line"><span class="comment"># -g,--generate部署之前预先生成静态文件</span></div><div class="line">hexo deploy</div><div class="line"></div><div class="line"><span class="comment"># 渲染文件，可选参数</span></div><div class="line"><span class="comment"># -o,--output设置输出路径</span></div><div class="line">hexo render &lt;file1&gt; [file2] ...</div><div class="line"></div><div class="line"><span class="comment"># 清理缓存文件和已经生成的静态文件</span></div><div class="line">hexo clean</div><div class="line"></div><div class="line">hexo migrate &lt;type&gt;<span class="comment"># 迁移其他网站内容</span></div><div class="line">hexo list &lt;type&gt;<span class="comment"># 列出网站资料</span></div><div class="line">hexo version<span class="comment"># 查看版本</span></div><div class="line">hexo --safe<span class="comment"># 安全模式</span></div><div class="line">hexo --debug<span class="comment"># 调试模式</span></div><div class="line">hexo --silent<span class="comment"># 简洁模式</span></div><div class="line">hexo --config custom.yml<span class="comment"># 自定义配置文件路径</span></div><div class="line">hexo --draft<span class="comment"># 显示草稿</span></div><div class="line">hexo --cwd /path/to/cwd<span class="comment"># 自定义当前工作目录</span></div></pre></td></tr></table></figure><p>最后几个命令不常用，需要的时候可以参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>。</p><h2 id="2-2、config-yml文件说明"><a href="#2-2、config-yml文件说明" class="headerlink" title="2.2、config.yml文件说明"></a>2.2、config.yml文件说明</h2><p>该文件主要用来配置网站本身的信息，如域名、名称、描述等，网站初始化后会默认新建本文件，配置项目包括：网站(site)、网址(URL)、目录(Directory)、文章(Writing)、主页信息(Home page setting)、分类标签(Category &amp; Tag)、分页(Pagination)、扩展(Extensions)、部署(Deployment)。下面对这些内容结合自己的实例进行逐项说明，详细的说明可以从<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>中查询。</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Hexo Configuration</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></div><div class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></div><div class="line"></div><div class="line"><span class="comment"># 网站Site</span></div><div class="line">title: FlyingFire<span class="comment"># 网站标题</span></div><div class="line">subtitle: a step further every day<span class="comment"># 网站副标题</span></div><div class="line">description:<span class="comment"># 网站描述，这边可以好好写以方便搜索引擎SEO</span></div><div class="line">author: FlyingFire<span class="comment"># 作者</span></div><div class="line">language:<span class="comment"># 网站使用的语言</span></div><div class="line">timezone:<span class="comment"># 时区，默认为当前电脑的时区</span></div><div class="line"></div><div class="line"><span class="comment"># 网址URL</span></div><div class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></div><div class="line">url: http://yoursite.com<span class="comment"># 网址</span></div><div class="line">root: /<span class="comment"># 网站根目录</span></div><div class="line">permalink: :year/:month/:day/:title/<span class="comment"># 文章永久链接格式</span></div><div class="line">permalink_defaults:<span class="comment"># 永久链接中各部分的默认值</span></div><div class="line"></div><div class="line"><span class="comment"># 目录Directory</span></div><div class="line">source_dir: source<span class="comment"># 资源文件夹</span></div><div class="line">public_dir: public<span class="comment"># 公共文件夹，用于存放生成站点的文件</span></div><div class="line">tag_dir: tags<span class="comment"># 标签文件夹</span></div><div class="line">archive_dir: archives<span class="comment"># 归档文件夹</span></div><div class="line">category_dir: categories<span class="comment"># 分类文件夹</span></div><div class="line">code_dir: downloads/code<span class="comment"># 包含代码片段的文件夹</span></div><div class="line">i18n_dir: :lang<span class="comment"># 国际化文件夹</span></div><div class="line">skip_render:<span class="comment"># 指定跳过文件的渲染</span></div><div class="line"></div><div class="line"><span class="comment"># 文章Writing</span></div><div class="line">new_post_name: :title.md<span class="comment"># 新文章名称</span></div><div class="line">default_layout: post<span class="comment"># 预设布局</span></div><div class="line">titlecase: false <span class="comment"># 将标题转换为Title Case格式(即英文单词第一个字母大写)</span></div><div class="line">external_link: true<span class="comment"># 在新链接中打开文件</span></div><div class="line">filename_case: <span class="number">0</span><span class="comment"># 讲文件名称转换为 (1) 小写或 (2) 大写</span></div><div class="line">render_drafts: false<span class="comment"># 显示草稿</span></div><div class="line">post_asset_folder: false<span class="comment"># 启动 Asset 文件夹</span></div><div class="line">relative_link: false<span class="comment"># 把链接改为与根目录的相对位址</span></div><div class="line">future: true<span class="comment"># 显示未来的文章</span></div><div class="line">highlight:<span class="comment"># 代码块的设置</span></div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line">  </div><div class="line"><span class="comment"># 主页设置Home page setting</span></div><div class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></div><div class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></div><div class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></div><div class="line">index_generator:</div><div class="line">  path: <span class="string">''</span></div><div class="line">  per_page: <span class="number">10</span><span class="comment"># 每页文章的数目 </span></div><div class="line">  order_by: -date<span class="comment"># 文章排序顺序</span></div><div class="line">  </div><div class="line"><span class="comment"># 分类标签Category &amp; Tag</span></div><div class="line">default_category: uncategorized<span class="comment"># 默认分类</span></div><div class="line">category_map:<span class="comment"># 分类别名</span></div><div class="line">tag_map:<span class="comment"># 标签别名</span></div><div class="line"></div><div class="line"><span class="comment"># 时间格式Date / Time format</span></div><div class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></div><div class="line"><span class="comment">## You can customize the date format as defined in</span></div><div class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></div><div class="line">date_format: YYYY-MM-DD<span class="comment"># 日期格式</span></div><div class="line">time_format: HH:mm:ss<span class="comment"># 时间格式</span></div><div class="line"></div><div class="line"><span class="comment"># 分页Pagination</span></div><div class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></div><div class="line">per_page: <span class="number">10</span><span class="comment"># 每页显示的文章量 (0 = 关闭分页功能)</span></div><div class="line">pagination_dir: page<span class="comment"># 分页目录</span></div><div class="line"></div><div class="line"><span class="comment"># 扩展Extensions</span></div><div class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></div><div class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></div><div class="line">theme: vexo<span class="comment"># 当前主题名称。值为false时禁用主题</span></div><div class="line"></div><div class="line"><span class="comment"># 部署Deployment</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></div><div class="line">deploy:</div><div class="line">  type: git<span class="comment"># 部署方式</span></div><div class="line">  repo: https://github.com/henan715/henan715.github.io.git  <span class="comment"># git地址</span></div></pre></td></tr></table></figure><h1 id="三、写博客"><a href="#三、写博客" class="headerlink" title="三、写博客"></a>三、写博客</h1><p>写博客有两种方法，一种是官方手册中说明的：在命令行切换到网站根目录下，执行<code>hexo new ***</code>，另一种是直接用第三方<code>Markdown</code>工具编写文档，然后拷贝到网站目录下<code>/source/_posts/</code>中，个人认为后者更容易，可以结合<code>Typora</code>软件，写起来更舒服。</p><p>这里注意，如果使用第二种方法，要在文件的头部插入一些信息，因为hexo生成的是静态的网页，需要根据文件头部的内容进行分类、显示标题等，默认情况下，格式应该如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: Hexo学习笔记</div><div class="line">date: <span class="number">2017</span><span class="number">-11</span><span class="number">-05</span> <span class="number">16</span>:<span class="number">42</span>:<span class="number">30</span></div><div class="line">tags:</div><div class="line">---</div><div class="line"></div><div class="line">正文内容</div></pre></td></tr></table></figure><p>这些内容在hexo中称为<code>front-matter</code>信息，当前支持的类别有：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>参数</td><td>描述</td><td>默认值</td></tr><tr><td><code>layout</code></td><td>布局</td><td></td></tr><tr><td><code>title</code></td><td>标题</td><td></td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章网址</td></tr></tbody></table></div><p>注意，只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><p>要是嫌插入麻烦，就用hexo生成文档然后用第三方编辑器打开编辑吧。</p><h3 id="3-1、资源文件夹"><a href="#3-1、资源文件夹" class="headerlink" title="3.1、资源文件夹"></a>3.1、资源文件夹</h3><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><h4 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h4><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_config.yml</div><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><h4 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h4><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img example.jpg This is an example image %&#125;</div></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h1 id="四、插件优化"><a href="#四、插件优化" class="headerlink" title="四、插件优化"></a>四、插件优化</h1><ol><li><a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="external">hexo-admin</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo学习笔记&quot;&gt;&lt;a href=&quot;#Hexo学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Hexo学习笔记&quot;&gt;&lt;/a&gt;Hexo学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Hexo是一个快速简洁的博客框架，使用Markdown解析文章，将内容生成静态网页，配合主题可以制作成精美的网页，将网页部署到github之后，你就有了一个免费的博客&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人感觉，面向开发者而言，博客应该是记录自己点滴积累的地方，它应该足够简洁，不应该有广告等元素干扰阅读，它应该是开发友好的，对程序员而言保持双手在键盘上，给我们顺滑流畅的书写过程，最后它应该足够强大，能让我们充分折腾，如何你也有这样的想法，那么&lt;code&gt;Hexo&lt;/code&gt;是一个十分不错的选择。&lt;/p&gt;
&lt;p&gt;本文档将按照官方文档的结构顺序从头到尾从网站初始化到部署到github完整的一个流程进行详细的说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
